{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/LocalReader/ArchiveParser.js","src/LocalReader/DataReader.js","src/LocalReader/FileTypes.js","src/LocalReader/LocalReader.js","src/LocalReader/PersistantStore.js","src/Logger.js","src/MapFileList.js","src/T3DLib.js","src/dataRenderer/DataRenderer.js","src/dataRenderer/EnvironmentRenderer.js","src/dataRenderer/HavokRenderer.js","src/dataRenderer/PropertiesRenderer.js","src/dataRenderer/SingleModelRenderer.js","src/dataRenderer/StringRenderer.js","src/dataRenderer/TerrainRenderer.js","src/dataRenderer/ZoneRenderer.js","src/format/file/GW2Chunk.js","src/format/file/GW2File.js","src/util/MaterialUtils.js","src/util/MathUtils.js","src/util/ParserUtils.js","src/util/RenderUtils.js","src/util/TerrainShader.js"],"names":["f","exports","module","define","amd","window","global","self","this","T3D","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","MathUtils","parseANDatHeader","ds","header","version","readUint8","magic","readString","headerSize","readUint32","seek","position","chunkSize","crc","mftOffset","arr32To64","mftSize","flags","Logger","log","TYPE_DEBUG","TYPE_ERROR","parseMFTTable","nbOfEntries","fullTable","item","readUint16","table","mftIndexOffset","offset","mftIndexSize","size","parseMFTIndex","indexTable","id","mftIndex","getFilePart","file","Promise","resolve","reject","reader","FileReader","onerror","onload","fileEvent","buffer","target","result","DataStream","endianness","LITTLE_ENDIAN","len","readAsArrayBuffer","slice","readArchive","async","archiveHeader","mftData","metaTable","[object Object]","settings","_settings","_workerPool","_workerLoad","_inflateCallbacks","workersNb","_startWorker","workerPath","mftId","isImage","capLength","arrayBuffer","byteLength","TYPE_WARNING","push","workerId","_getBestWorkerIndex","postMessage","path","worker","Worker","selfWorkerId","onmessage","message_event","data","split","callback","dxtType","imageWidth","imageHeight","indexOf","Math","min","GW2File","FileTypes","getFileType","first4","readCString","type","ArchiveParser","PersistantStore","DataReader","MapFileList","_dataReader","_persistantStore","_file","undefined","_indexTable","_fileMetaTable","noIndexedDB","baseId","raw","fileLength","extractLength","meta","getFileMeta","compressed","inflate","then","catch","oldFileList","persistantId","persistantList","lastListing","getLastListing","name","array","complete","key","iterateList","Object","keys","map","Number","index","taskArray","task","persistantNeedsUpdate","_needsScan","scan","taskId","race","_readFileType","scanResult","fileType","change","floor","TYPE_PROGRESS","putListing","res","all","_persistantData","getFileList","mapArray","reversedIndex","getReverseIndex","maps","filter","getFileIndex","found","category","fileMap","find","fileName","toString","mapEntry","typeList","reverseBaseIdList","fileList","baseIds","baseIdList","reduce","reversed","searchAll","restoreOuput","returnArray","elt","findIndex","sort","j","readFileList","getMapList","returnObj","fileEntry","readFile","loadFile","persistantData","metaData","_fileTypeCache","fileBuffer","DB_VERSION","_dbConnection","_getConnection","request","indexedDB","open","onblocked","onupgradeneeded","event","db","currentVersion","oldVersion","createObjectStore","autoIncrement","currentTarget","transaction","objectStore","createIndex","unique","onsuccess","isReady","listing","isComplete","store","put","filename","openCursor","IDBKeyRange","only","cursor","value","primaryKey","TYPE_MESSAGE","logFunctions","Array","arguments","argArr","argsToArr","unshift","severity","max","shift","apply","args","console","error","warn","debug","LocalReader","t3dtoolsWorker","concurrentTasks","navigator","hardwareConcurrency","GW2Chunk","DataRenderer","EnvironmentRenderer","HavokRenderer","PropertiesRenderer","SingleModelRenderer","TerrainRenderer","ZoneRenderer","StringRenderer","MaterialUtils","ParserUtils","RenderUtils","getLocalReader","lrInstance","openArchive","getFileListAsync","localReader","loadFileList","readFileListAsync","getMapListAsync","readMapListAsync","mapList","loadMapList","renderMapContentsAsync","renderers","logger","runAllRenderers","context","parseInt","mapFile","runRenderer","renderClass","assign","bind","cb","renderAsync","getContextValue","clazz","propName","defaultValue","output","hasWebGL","return_context","WebGLRenderingContext","canvas","document","createElement","names","getContext","getParameter","gl","numErrors","THREE","checkRequirements","constructor","prototype","getOutput","otherClass","inflatedData","fileId","rawData","uarr","Uint8Array","rawStrings","String","fromCharCode","subarray","rawString","join","loadTextureFile","imageHeigth","image","width","height","getMat","tex","MeshBasicMaterial","side","BackSide","fog","depthWrite","loadTextureWithFallback","targetMatIndices","materialArray","fallbackFilename","hazeColorAsInt","writeMat","mat","forEach","loadFallback","TextureLoader","load","loadLocalTexture","setTimeout","getHazeColor","environmentChunkData","hazes","dataGlobal","haze","farColor","parseLights","lights","ambientLight","lighting","backlightIntensity","backlightColor","hasLight","light","sumDirLightIntensity","dirLightData","color","Color","directionalLight","DirectionalLight","getHex","intensity","set","direction","normalize","lightDir","AmbientLight","ambientTotal","g","b","parseSkybox","parameterChunkData","skyElements","skyModeTex","texPathNE","texPathSW","texPathT","bounds","rect","mapW","abs","x1","x2","mapD","y1","y2","visible","skyGeometry","BoxGeometry","boxSize","faceVertexUvs","vecs","idx","face","vec2","x","y","uvsNeedUpdate","skyBox","Mesh","translateY","create","getChunk","hazeColor","lastP","seed","meshes","renderModels","models","title","MeshNormalMaterial","DoubleSide","parseAllModels","getCollisionsForAnimation","animation","collisions","ret","collisionIndices","collision","round","animationFromGeomIndex","geometryIndex","geometries","animations","havokChunkData","renderMesh","propGeomIndex","l","model","pos","translate","rot","rotate","scale","mesh","parseHavokMesh","rotation","order","seedRandom","sin","clone","geom","Geometry","vertices","v","Vector3","indices","f1","f2","f3","faces","Face3","computeFaceNormals","boundingBox","boundsMax","propModels","zoneModels","obsModels","mdl","renderZoneModelsCB","propertiesChunkData","props","propArray","animProps","propAnimArray","instanceProps","propInstanceArray","metaProps","propMetaArray","concat","meshCache","textureCache","lastPct","renderIndex","pct","pctStr","prop","addMeshToLOD","groups","lod","needsClone","lodDist","lod2","lodOverride","geometry","material","updateMatrix","matrixAutoUpdate","add","group","Group","addLevel","getMeshesForFilename","isCached","boundingSphere","meshArray","LOD","maxDist","boundingSphereRadius","radius","transforms","transform","update","addMeshesToScene","getFileIdsAsync","fileIds","getIdsForProp","getFilesUsedByModel","propFileIds","strings","end","entryHeaderDef","entryIndex","entry","readStruct","decryptionOffset","bitsPerSymbol","readUCS2String","recid","language","TerrainShader","drawWater","wireframe","opacity","transparent","renderRect","parseNumChunks","terrainData","numChunksD_1","sqrt","dims","chunkArray","numChunksD_2","loadPagedImageCallback","infaltedBuffer","terrainTiles","pimgDS","pimgTableDataChunk","pimgData","mapRect","parameterData","maxAnisotropy","anisotropy","xChunks","yChunks","allMaterials","materials","allTextures","texFileArray","dx","dy","cdx","cdy","allMats","customMaterial","MeshLambertMaterial","flatShading","chunkTextures","strippedPages","page","layer","coord","matName","chunkTex","wrapS","RepeatWrapping","wrapT","stepChunk","cx","cy","water","chunkIndex","pageX","pageY","chunkTextureIndices","loResMaterial","texIndexArray","pageOffetX","pageOffetY","fileNames","gi","textureFileName","pageTexName","pageTexName2","near","far","envOutput","uniforms","UniformsUtils","merge","UniformsLib","uvScale","Vector2","texturePicker","texturePicker2","texture1","texture2","texture3","texture4","ShaderMaterial","fragmentShader","getFragmentShader","vertexShader","getVertexShader","chunkGeo","PlaneBufferGeometry","chunkW","cn","getAttribute","heightMapArray","chunk","mS","Matrix4","identity","elements","applyMatrix","SceneUtils","createMultiMaterialObject","PI","globalOffsetX","chunkOffsetX","globalOffsetY","chunkOffsetY","z","px","py","updateMatrixWorld","renderChunk","pagedImageId","pagedImage","terrainChunk","texture","renderZone","zone","zoneDefs","renderZoneCallback","zoneDef","zd","token","defToken","modelGroups","getModelGroups","groupKeys","stepModels","meshGroups","instanceIdx","meshIdx","materialFlags","move","mg","readVerts","verts","Float32Array","readIndices","getIndex","Uint32Array","readUVs","uvs","readNormals","normals","writeVerts","stride","writeIndices","strideIndices","writeUvs","uvStride","writeNormals","normalStride","meshGroup","mergedGeom","BufferGeometry","addAttribute","BufferAttribute","setIndex","buffersNeedUpdate","mapX","mapY","zoneRect","vertRect","encodeData","zdx","linearPos","flag","zoneDefLayer","layerDefArray","modelX","modelY","modelZ","startZ","raycaster","Raycaster","intersections","intersectObject","distance","modelIdx","modelFilename","modelArray","rotRangeX","rotRangeY","rotRangeZ","scaleRange","fadeRange","zoneChunkData","zones","zoneArray","zoneDefArray","stepZone","HEAD_STRUCT","DUPLICATE_SETTINGS","PACKTOCHUNK","pack","root","addr","setting","regex","RegExp","chunkDef","formats","defsIdx","defs","versions","getRootName","pop","match","definition","__root","genDuplicateSettings","headerLength","NaN","loadHead","useNthIndex","fileTypes","defsFound","chunkVersion","def","getDefinition","chunkDataSize","Chunk","noChunks","chunks","readHead","readChunks","ch","loadData","next","toLowerCase","buildVS","numUv","vdefs","adefs","reads","generateDataTexture","DataTexture","RGBAFormat","buildPS","textures","alphaTest","lightMap","t1uv","uvIdx","discard","writeColor","varyings","getUVMat","numUV","attributes","vs","FrontSide","getTexture","texURL","sharedTextures","finalTexture","flipY","mapping","defaultColor","random","minFilter","LinearMipMapLinearFilter","magFilter","LinearFilter","generateMipmaps","format","needsUpdate","getMaterial","materialFile","finalMaterial","dxChunk","grChunk","finalTextures","textureToken","samplerTex","effect","techniques","passes","effects","samplerTextures","samplerIndex","samplerIdx","sampler","samplers","texTokens","textureIndex","uvPSInputIndex","ft","nt","MeshPhongMaterial","normalMap","textureFilename","shading","FlatShading","alphaMask0","alphaMask1","lightMask","base32Max","pow","f16","h","s","Infinity","popcount","bits","arr","sort_unique","arr_in","comparator","hasOwnProperty","getArrayReader","structDef","maxCount","struct","arr_len","arr_ptr","readType","getRefArrayReader","ret_arr","orgPos","offsets","readInt32Array","pointer","getQWordReader","getStringReader","ptr","getString16Reader","stringOffset","num","getPointerReader","getFileNameReader","fileRef","m_highPart","m_lowPart","matFiles","fvfFormat","Position","Weights","Normal","Tangent","Bitangent","TangentFrame","UV32Mask","UV16Mask","Unknown1","Unknown2","Unknown3","Unknown4","PositionCompressed","Unknown5","renderGeomChunk","modelDataChunk","showUnmaterialed","rawMeshes","mats","permutations","rawMesh","rawGeom","fvf","numVerts","vertexCount","rawVerts","vertDS","distToUV","uv32Flag","uv16Flag","isUV32","hasUV","masked","readFloat32","Uint16Array","computeVertexNormals","uvName","matIdx","materialIndex","finalMesh","materialFilename","materialName","numLods","lods","loadMeshFromModelFile","solidColor","finalMeshes","modelFile","geometryDataChunk","bsc","center","loadMaterialIndex","mIdx","matCallback","yPos","dz","cz","plane","overdraw","sharedMeshes","matFileName","ShaderChunk"],"mappings":"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","file":"T3D-1.1.0.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst MathUtils = require(\"../util/MathUtils\");\r\n\r\n/**\r\n * @file The ArchiveParser module is a set of helper tools to correctly read the Archive.\r\n * @namespace ArchiveParser\r\n */\r\n\r\n/**\r\n *    All in one function to read a GW2.dat file and parse all the needed informations to work with it\r\n *\r\n * @memberof ArchiveParser\r\n * @param {File} file\r\n * @returns {Promise<{archiveHeader: ArchiveHeader, metaTable: MetaTable, indexTable: IndexTable}>}\r\n */\r\nasync function readArchive(file) {\r\n  let archiveHeader = parseANDatHeader((await getFilePart(file, 0, 40)).ds);\r\n  let mftData = parseMFTTable(\r\n    (await getFilePart(file, archiveHeader.mftOffset, archiveHeader.mftSize)).ds\r\n  );\r\n  let { ds, len } = await getFilePart(\r\n    file,\r\n    mftData.mftIndexOffset,\r\n    mftData.mftIndexSize\r\n  );\r\n  let indexTable = parseMFTIndex(ds, len);\r\n\r\n  return {\r\n    archiveHeader: archiveHeader,\r\n    metaTable: mftData.table,\r\n    indexTable: indexTable\r\n  };\r\n}\r\n\r\n/**\r\n * The header of the archive.\r\n * @typedef {Object} ArchiveHeader\r\n * @property {number} version\r\n * @property {number} magic\r\n * @property {number} headerSize\r\n * @property {number} chunkSize\r\n * @property {number} crc\r\n * @property {number} mftOffset\r\n * @property {number} mftSize\r\n * @property {number} flags\r\n */\r\n\r\n/**\r\n *   Parse the main information about the archive like format version, positions of information tables, crc etc...\r\n *\r\n * @memberof ArchiveParser\r\n * @param {DataStream} ds\r\n * @returns {ArchiveIndex} Returns undefined if the header couldn't be parsed\r\n */\r\nfunction parseANDatHeader(ds) {\r\n  let header = {};\r\n\r\n  // Header parsing\r\n  header.version = ds.readUint8();\r\n  header.magic = ds.readString(3);\r\n  header.headerSize = ds.readUint32();\r\n  ds.seek(ds.position + 4); // Skip uint32\r\n  header.chunkSize = ds.readUint32();\r\n  header.crc = ds.readUint32();\r\n  ds.seek(ds.position + 4); // Skip uint32\r\n  header.mftOffset = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\r\n  header.mftSize = ds.readUint32();\r\n  header.flags = ds.readUint32();\r\n  // End header parsing\r\n\r\n  // Check MAGIC\r\n  if (header.magic !== \"AN\\u001A\") {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_ERROR,\r\n      \"ANDat header is not valid\",\r\n      header.magic\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded Main .dat header\");\r\n\r\n  return header;\r\n}\r\n\r\n/**\r\n * The array containing all the meta information concerning the contained files\r\n * @typedef {Array<{offset: number, size: number, compressed: number, crc: number}>} MetaTable\r\n */\r\n\r\n/**\r\n *   Parse the main information table that contains the offset, size, compression flags and crc\r\n *\r\n * @memberof ArchiveParser\r\n * @param {Datastream}  ds\r\n * @returns {{header: {magic: String, nbOfEntries: number}, table: MetaTable, mftIndexOffset: number, mftIndexSize: number}|undefined}\r\n *   Returns undefined if it couldn't parse the table\r\n */\r\nfunction parseMFTTable(ds) {\r\n  // Parse the table header\r\n  let header = {};\r\n  header.magic = ds.readString(4);\r\n  ds.seek(ds.position + 8); // Skip uint64\r\n  header.nbOfEntries = ds.readUint32();\r\n  ds.seek(ds.position + 4 + 4); // Skip uint32 * 2\r\n\r\n  // check MAGIC\r\n  if (header.magic !== \"Mft\\u001A\") {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_ERROR,\r\n      \"MFTTable header is not valid\",\r\n      header.magic\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  // Where we put all the parsed data\r\n  // We don't pre-alloc anymore since not having the data aligned together procs too many\r\n  // cache misses during a fullscan\r\n  let fullTable = [];\r\n\r\n  // Go through the table\r\n  for (let i = 1; i < header.nbOfEntries; i++) {\r\n    let item = {};\r\n    item[\"offset\"] = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\r\n    item[\"size\"] = ds.readUint32();\r\n    item[\"compressed\"] = ds.readUint16();\r\n    ds.seek(ds.position + 4 + 2); // Skip uint16 + uint32\r\n    item[\"crc\"] = ds.readUint32();\r\n    fullTable[i] = item;\r\n  }\r\n\r\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded MFTTable\");\r\n\r\n  return {\r\n    header: header,\r\n    table: fullTable,\r\n    // Register the MFTIndex table position and size\r\n    mftIndexOffset: fullTable[2].offset,\r\n    mftIndexSize: fullTable[2].size\r\n  };\r\n}\r\n\r\n/**\r\n * The array linking all the file indexes to their respective files\r\n * @typedef {Array<number>} IndexTable\r\n */\r\n\r\n/**\r\n *   This function used to be much more complex with the use of\r\n *   a \"fileId\" which in the end was just the equivalent of\r\n *   MFTbaseIds[mftId].sort().reverse()[0] (aka the bigger baseId found)\r\n *\r\n * @memberof ArchiveParser\r\n * @param {DataStream} ds\r\n * @param {number} size\r\n * @returns {IndexTable}\r\n */\r\nfunction parseMFTIndex(ds, size) {\r\n  let length = size / 8;\r\n\r\n  let indexTable = [];\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    // Parse table\r\n    let id = ds.readUint32();\r\n    let mftIndex = ds.readUint32();\r\n    // Store the values\r\n    indexTable[id] = mftIndex;\r\n  }\r\n\r\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Finished indexing MFT\");\r\n\r\n  return indexTable;\r\n}\r\n\r\n/**\r\n *   Get a chunk of the specified file. Used mainly to take parts of the Archive before parsing.\r\n *\r\n * @memberof ArchiveParser\r\n * @param {File} file\r\n * @param {number} offset\r\n * @param {number} length\r\n * @returns {Promise<{ds: DataStream, len: number}>}\r\n */\r\nfunction getFilePart(file, offset, length) {\r\n  return new Promise((resolve, reject) => {\r\n    let reader = new FileReader();\r\n\r\n    reader.onerror = reject;\r\n\r\n    reader.onload = function(fileEvent) {\r\n      let buffer = fileEvent.target.result;\r\n      let ds = new DataStream(buffer);\r\n      ds.endianness = DataStream.LITTLE_ENDIAN;\r\n      // Pass data stream and data length to callback function\r\n      resolve({ ds: ds, len: length });\r\n    };\r\n\r\n    // Slicing a File is just reducing the scope of the ArrayBuffer, but doesn't load anything in memory.\r\n    reader.readAsArrayBuffer(file.slice(offset, offset + length));\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  readArchive: readArchive,\r\n  parseANDatHeader: parseANDatHeader,\r\n  parseMFTTable: parseMFTTable,\r\n  parseMFTIndex: parseMFTIndex,\r\n  getFilePart: getFilePart\r\n};\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/**\r\n * Organized thread pool of extractors\r\n * @class DataReader\r\n */\r\nclass DataReader {\r\n  /**\r\n   * @constructor\r\n   * @param {Object} settings\r\n   * @param {number} settings.workersNb Amount of concurrent spawned workers\r\n   * @param {string} settings.workerPath Path to the worker script\r\n   */\r\n  constructor(settings) {\r\n    this._settings = settings;\r\n    this._workerPool = [];\r\n    this._workerLoad = [];\r\n    this._inflateCallbacks = [];\r\n    for (let i = 0; i < settings.workersNb; i++) {\r\n      this._startWorker(settings.workerPath);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {DataStream} ds\r\n   * @param {number} size\r\n   * @param {number} mftId\r\n   * @param {boolean} [isImage] Parses the output as a dxt texture\r\n   * @param {number} [capLength] Output size\r\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number, imageWidth: number, imageHeight: number}>}\r\n   */\r\n  inflate(ds, size, mftId, isImage, capLength) {\r\n    return new Promise((resolve, reject) => {\r\n      let arrayBuffer = ds.buffer;\r\n\r\n      // If no capLength then inflate the whole file\r\n      if (!capLength || capLength < 0) {\r\n        capLength = 0;\r\n      }\r\n\r\n      // Buffer length size check\r\n      if (arrayBuffer.byteLength < 12) {\r\n        T3D.Logger.log(\r\n          T3D.Logger.TYPE_WARNING,\r\n          `not inflating, length is too short (${arrayBuffer.byteLength})`,\r\n          mftId\r\n        );\r\n        reject(new Error(\"Couldn't inflate \" + mftId + \" (mftId)\"));\r\n        return;\r\n      }\r\n\r\n      // Register the callback\r\n      if (this._inflateCallbacks[mftId]) {\r\n        this._inflateCallbacks[mftId].push({\r\n          resolve: resolve,\r\n          reject: reject\r\n        });\r\n\r\n        /// No need to make another call, just wait for callback event to fire.\r\n        return;\r\n      } else {\r\n        this._inflateCallbacks[mftId] = [{ resolve: resolve, reject: reject }];\r\n      }\r\n\r\n      // Add the load to the worker\r\n      let workerId = this._getBestWorkerIndex();\r\n      this._workerLoad[workerId] += 1;\r\n      this._workerPool[workerId].postMessage([\r\n        mftId,\r\n        arrayBuffer,\r\n        isImage === true,\r\n        capLength\r\n      ]);\r\n    });\r\n  }\r\n\r\n  // Initialization function for creating a new worker (thread)\r\n  _startWorker(path) {\r\n    let self = this;\r\n    let worker = new Worker(path);\r\n    let selfWorkerId = this._workerPool.push(worker) - 1;\r\n    if (this._workerLoad.push(0) !== selfWorkerId + 1) {\r\n      throw new Error(\"WorkerLoad and WorkerPool don't have the same length\");\r\n    }\r\n\r\n    worker.onmessage = function(message_event) {\r\n      let mftId;\r\n      // Remove load\r\n      self._workerLoad[selfWorkerId] -= 1;\r\n\r\n      // If error\r\n      if (typeof message_event.data === \"string\") {\r\n        T3D.Logger.log(\r\n          T3D.Logger.TYPE_WARNING,\r\n          \"Inflater threw an error\",\r\n          message_event.data\r\n        );\r\n        mftId = message_event.data.split(\":\")[0];\r\n        for (let callback of self._inflateCallbacks[mftId]) {\r\n          callback.reject();\r\n        }\r\n      } else {\r\n        mftId = message_event.data[0];\r\n        // On success\r\n        if (self._inflateCallbacks[mftId]) {\r\n          for (let callback of self._inflateCallbacks[mftId]) {\r\n            let data = message_event.data;\r\n            // Array buffer, dxtType, imageWidth, imageHeight\r\n            callback.resolve({\r\n              buffer: data[1],\r\n              dxtType: data[2],\r\n              imageWidth: data[3],\r\n              imageHeight: data[4]\r\n            });\r\n          }\r\n          // Remove triggered listeners\r\n          self._inflateCallbacks[mftId] = null;\r\n        }\r\n\r\n        // Unknown error\r\n        else {\r\n          T3D.Logger.log(\r\n            T3D.Logger.TYPE_ERROR,\r\n            \"Inflater threw an error\",\r\n            message_event.data\r\n          );\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  // Get the worker with the less load\r\n  _getBestWorkerIndex() {\r\n    return this._workerLoad.indexOf(Math.min(...this._workerLoad));\r\n  }\r\n}\r\n\r\nmodule.exports = DataReader;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst GW2File = require(\"../format/file/GW2File.js\");\r\n\r\n/**\r\n * @namespace FileTypes\r\n */\r\n\r\nlet FileTypes = {};\r\n\r\n/**\r\n * Parse the beginning of a file to find its type\r\n *\r\n * @memberof FileTypes\r\n * @param {DataStream} ds\r\n * @return {number}\r\n */\r\nFileTypes.getFileType = function(ds) {\r\n  let first4 = ds.readCString(4);\r\n\r\n  // Parse textures\r\n  switch (first4) {\r\n    case \"ATEC\":\r\n      return \"TEXTURE_ATEC\";\r\n    case \"ATEP\":\r\n      return \"TEXTURE_ATEP\";\r\n    case \"ATET\":\r\n      return \"TEXTURE_ATET\";\r\n    case \"ATEU\":\r\n      return \"TEXTURE_ATEU\";\r\n    case \"ATEX\":\r\n      return \"TEXTURE_ATEX\";\r\n    case \"ATTX\":\r\n      return \"TEXTURE_ATTX\";\r\n  }\r\n\r\n  if (first4.indexOf(\"DDS\") === 0) return \"TEXTURE_DDS\";\r\n\r\n  if (first4.indexOf(\"PNG\") === 1) return \"TEXTURE_PNG\";\r\n\r\n  if (first4.indexOf(\"RIFF\") === 0) return \"TEXTURE_RIFF\";\r\n\r\n  if (first4.indexOf(\"YUI\") === 0) return \"TEXT_YUI\";\r\n\r\n  // PackFiles\r\n  if (first4.indexOf(\"PF\") === 0) {\r\n    let file = new GW2File(ds, 0, true); /// true for \"plz no load chunkz\"\r\n    return \"PF_\" + file.header.type;\r\n  }\r\n\r\n  // Binaries\r\n  if (first4.indexOf(\"MZ\") === 0) return \"BINARIES\";\r\n\r\n  // Strings\r\n  if (first4.indexOf(\"strs\") === 0) return \"STRINGS\";\r\n\r\n  // Raw asnd chunk (without pack file)\r\n  if (first4.indexOf(\"asnd\") === 0) return \"CHUNK_ASND\";\r\n\r\n  // TODO: parse all datastream and if all bytes are valid unicode symbols then\r\n  // return TEXT_UNKNOWN;\r\n\r\n  // Unknown\r\n  return \"UNKNOWN\";\r\n};\r\n\r\nmodule.exports = FileTypes;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst ArchiveParser = require(\"./ArchiveParser\");\r\nconst PersistantStore = require(\"./PersistantStore\");\r\nconst DataReader = require(\"./DataReader\");\r\nconst MapFileList = require(\"../MapFileList\");\r\nconst FileTypes = require(\"./FileTypes\");\r\n\r\n/**\r\n * A statefull class that handles reading and inflating data from a local GW2 dat file.\r\n * LocalReader have been completely rewritten from scratch,\r\n * the API changed quite a lot between 1.0.4 and 1.1.0.\r\n *\r\n * API CHANGES: LocalReader (1.1.0 from 1.0.4)\r\n * - The constructor have __changed__.\r\n * - parseHeaderAsync have been __removed__.\r\n * - connectInflated have been __removed__.\r\n * - NaClListener have been __removed__.\r\n * - readANDatHeader have been __removed__.\r\n * - readMFTHeader have been __removed__.\r\n * - readMFTIndexFile have been __removed__.\r\n * - loadFileList is now __deprecated__.\r\n * - loadMapList is now __deprecated__.\r\n * - storeFileList have been __removed__.\r\n * - storeMapList have been __removed__.\r\n * - readFileListAsync is now __deprecated__.\r\n * - readMapListAsync is now __deprecated__.\r\n * - listFiles have been __removed__.\r\n * - getFileIndex have been slightly __changed__.\r\n * - loadTextureFile is now __deprecated__.\r\n * - loadFile have been __removed__.\r\n * - inflate have been __removed__.\r\n * - loadFilePart have been __removed__.\r\n *\r\n * @param {{workerPath: String, workersNb: number, noIndexedDB: boolean}} settings\r\n *   * workerPath: the path to the t3dtools worker script file.\r\n *   * workersNb: amount of threads spawned for decompression.\r\n *   * noIndexedDB: Do not use indexedDB (persistant storage, default is true)\r\n */\r\nclass LocalReader {\r\n  constructor(settings) {\r\n    this._settings = settings;\r\n\r\n    /**\r\n     * @private\r\n     * @type {DataReader}\r\n     */\r\n    this._dataReader = new DataReader(settings);\r\n\r\n    /**\r\n     * @private\r\n     * @type {PersistantStore}\r\n     */\r\n    this._persistantStore;\r\n\r\n    /**\r\n     * @private\r\n     * @type {File}\r\n     */\r\n    this._file = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this._indexTable = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<{offset: number, size: number, compressed: number, crc: number}>}\r\n     */\r\n    this._fileMetaTable = [];\r\n\r\n    if (settings.noIndexedDB !== false) {\r\n      this._persistantStore = new PersistantStore();\r\n    }\r\n  }\r\n\r\n  /**\r\n   *   Asynchronously loads the archive by parsing its file index and header.\r\n   *\r\n   * @param {File} file\r\n   * @returns {Promise}\r\n   */\r\n  async openArchive(file) {\r\n    let { metaTable, indexTable } = await ArchiveParser.readArchive(file);\r\n    this._fileMetaTable = metaTable;\r\n    this._indexTable = indexTable;\r\n    this._file = file;\r\n  }\r\n\r\n  /**\r\n   *   Gets MFT index by baseId\r\n   *\r\n   * @param  {Number} baseId   A base Id\r\n   * @return {Number}          MFT index\r\n   */\r\n  getFileIndex(baseId) {\r\n    return this._indexTable[baseId];\r\n  }\r\n\r\n  /**\r\n   *   \"Meta\" informations to deal with files in the archive.\r\n   * @typedef     {Object}    FileMetaData\r\n   * @property    {number}    offset\r\n   * @property    {number}    size\r\n   * @property    {number}    compressed\r\n   * @property    {number}    crc\r\n   */\r\n\r\n  /**\r\n   *   Returns the metadata of a file stored in the archive\r\n   *\r\n   * @param {number} mftId Mft index of the file\r\n   * @returns {FileMetaData} Metadata informations\r\n   */\r\n  getFileMeta(mftId) {\r\n    return this._fileMetaTable[mftId];\r\n  }\r\n\r\n  /**\r\n   *   Fetch a file and uncompress it if needed / required.\r\n   *\r\n   * @param {number} mftId File's archive ID\r\n   * @param {boolean} [isImage] Try to read the data as a Dxt texture.\r\n   * @param {boolean} [raw] Force no decompression.\r\n   * @param {number} [fileLength] Slice the uncompressed file.\r\n   * @param {number} [extractLength] Slice the decompression.\r\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number|undefined, imageWidth: number|undefined, imageHeight: number|undefined}>}\r\n   */\r\n  async readFile(mftId, isImage, raw, fileLength, extractLength) {\r\n    //let buffer, dxtType, imageWidth, imageHeight;\r\n    let meta = this.getFileMeta(mftId);\r\n    if (!meta) throw new Error(\"Unexistant file\");\r\n\r\n    // Slice up the data\r\n    let { ds, len } = await ArchiveParser.getFilePart(\r\n      this._file,\r\n      meta.offset,\r\n      fileLength || meta.size\r\n    );\r\n\r\n    // If needed we decompress, if not we keep raw\r\n    if (meta.compressed || raw !== false) {\r\n      let data;\r\n      await this._dataReader\r\n        .inflate(ds, len, mftId, isImage, extractLength || 0)\r\n        .then(result => {\r\n          data = result;\r\n        })\r\n        .catch(() => {\r\n          data = {\r\n            buffer: undefined,\r\n            dxtType: undefined,\r\n            imageWidth: undefined,\r\n            imageHeight: undefined\r\n          };\r\n        });\r\n      return data;\r\n    } else return { buffer: ds.buffer };\r\n  }\r\n\r\n  /**\r\n   *   Scans asynchronously the types of all the files listed in the archive.\r\n   *   Uses persistant store to cache and speed up a rescan.\r\n   *\r\n   * @param {Array<{baseId: number, size: number, crc: number, fileType: string}>|undefined} oldFileList\r\n   *   Way for platform not supporting indexDB to provide their own persistant storage.\r\n   * @returns {Promise<Array<FileItem>>}\r\n   */\r\n  async readFileList(oldFileList) {\r\n    let self = this;\r\n\r\n    let persistantList = oldFileList || [];\r\n    let persistantId;\r\n\r\n    // Load previously saved data\r\n    if (this._persistantStore) {\r\n      let lastListing = await this._persistantStore.getLastListing(\r\n        this._file.name\r\n      );\r\n      persistantList = lastListing.array;\r\n      // If the last scan was not completed then we will just update it..\r\n      if (!lastListing.complete) {\r\n        persistantId = lastListing.key;\r\n      }\r\n    }\r\n\r\n    // Create a list of all the baseIds we need to inspect\r\n    let iterateList = Object.keys(self._indexTable).map(i => Number(i));\r\n    for (let index in persistantList) {\r\n      if (!(index in self._indexTable)) iterateList.push(index);\r\n    }\r\n\r\n    // Helps us to know when we need to update the persistant store\r\n    // let updatePersistant = false;\r\n\r\n    // Spawn the decompression tasks\r\n    let taskArray = [];\r\n    for (let i = 0; i < 1; i++) {\r\n      taskArray[i] = Promise.resolve({ task: i });\r\n    }\r\n\r\n    let persistantNeedsUpdate = false;\r\n\r\n    // Iterate through the array\r\n    for (let index in iterateList) {\r\n      let baseId = iterateList[index];\r\n\r\n      // First use a synchronous function to know if we need to scan the file\r\n      let result = this._needsScan(baseId, persistantList);\r\n      if (result.scan === true) {\r\n        let taskId = (await Promise.race(taskArray)).task;\r\n        taskArray[taskId] = this._readFileType(baseId).then(scanResult => {\r\n          // Put the result into our persistant storage\r\n          persistantList[baseId] = {\r\n            baseId: baseId,\r\n            size: scanResult.size,\r\n            crc: scanResult.crc,\r\n            fileType: scanResult.fileType\r\n          };\r\n          return { task: taskId };\r\n        });\r\n      }\r\n      if (result.change === \"removed\") {\r\n        // Update the persistant storage\r\n        delete persistantList[baseId];\r\n      }\r\n\r\n      // Handle persistant storage update\r\n      if (result.change !== \"none\") persistantNeedsUpdate = true;\r\n\r\n      // Tasks to do only every %\r\n      if (index % Math.floor(iterateList.length / 100) === 0) {\r\n        // Print progress\r\n        T3D.Logger.log(\r\n          T3D.Logger.TYPE_PROGRESS,\r\n          \"Finding types\",\r\n          index / Math.floor(iterateList.length / 100)\r\n        );\r\n\r\n        // Update the persistant storage if needed\r\n        if (self._persistantStore && persistantNeedsUpdate) {\r\n          persistantNeedsUpdate = false;\r\n          self._persistantStore\r\n            .putListing(persistantId, persistantList, self._file.name, false)\r\n            .then(res => (persistantId = res));\r\n        }\r\n      }\r\n    }\r\n\r\n    await Promise.all(taskArray).then(() => {\r\n      // Finally update the listing as complete\r\n      if (self._persistantStore) {\r\n        self._persistantStore.putListing(\r\n          persistantId,\r\n          persistantList,\r\n          self._file.name,\r\n          true\r\n        );\r\n      }\r\n    });\r\n    this._persistantData = persistantList;\r\n    return this.getFileList();\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} MapItem\r\n   * @property {string} name\r\n   * @property {string} category\r\n   * @property {number} baseId\r\n   */\r\n\r\n  /**\r\n   *   Returns a list of all the maps with their name and category.\r\n   *   Uncategorized maps are available only if readFileList have been used before.\r\n   *\r\n   * @returns {Array<MapItem>}\r\n   */\r\n  getMapList() {\r\n    let self = this;\r\n    let mapArray = [];\r\n    // If the archive have been scanned for all its file we iterate through the results\r\n    if (this._persistantData) {\r\n      // Filter the maps out of all our files\r\n      let reversedIndex = this.getReverseIndex();\r\n      let maps = this._persistantData\r\n        .filter(file => file.fileType === \"PF_mapc\")\r\n        .filter(\r\n          id => id.baseId === reversedIndex[self.getFileIndex(id.baseId)][0]\r\n        );\r\n\r\n      for (let map of maps) {\r\n        let found = false;\r\n        // Try to see if we already have some informations on this map\r\n        for (let category of MapFileList.maps) {\r\n          let fileMap = category.maps.find(\r\n            item => Number(item.fileName.split(\".data\")[0]) === map.baseId\r\n          );\r\n          if (fileMap) {\r\n            mapArray.push({\r\n              name: fileMap.name,\r\n              category: category.name,\r\n              baseId: map.baseId\r\n            });\r\n            found = true;\r\n            break;\r\n          }\r\n        }\r\n        // If not we register it as Uncategorized\r\n        if (!found) {\r\n          mapArray.push({\r\n            name: map.baseId.toString(),\r\n            category: \"Uncategorized\",\r\n            baseId: map.baseId\r\n          });\r\n        }\r\n      }\r\n    }\r\n    // If not then we check only known maps\r\n    else {\r\n      for (let category of MapFileList.maps) {\r\n        for (let mapEntry of category.maps) {\r\n          if (Number(mapEntry.fileName.split(\".data\")[0]) in this._indexTable) {\r\n            mapArray.push({\r\n              name: mapEntry.name,\r\n              category: category.name,\r\n              baseId: Number(mapEntry.fileName.split(\".data\")[0])\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return mapArray;\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} FileItem\r\n   * @property {number} mftId\r\n   * @property {Array<number>} baseIdList\r\n   * @property {number} size\r\n   * @property {number} crc\r\n   * @property {string} fileType\r\n   **/\r\n\r\n  /**\r\n   *   Return the meta table with extra information such as an array of baseIds and the file types.\r\n   *   The filetype is available only if readFileList have been used before of course.\r\n   *\r\n   * @returns {Array<FileItem>}\r\n   */\r\n  getFileList() {\r\n    let typeList = this._persistantData\r\n      ? this._persistantData.map(i => i.fileType)\r\n      : [];\r\n    let reverseBaseIdList = this.getReverseIndex();\r\n\r\n    let fileList = this._fileMetaTable.map((meta, mftId) => {\r\n      let baseIds = reverseBaseIdList[mftId] ? reverseBaseIdList[mftId] : [];\r\n      let type = reverseBaseIdList[mftId]\r\n        ? typeList[baseIds[0]]\r\n        : \"Non-Registered\";\r\n      return {\r\n        mftId: mftId,\r\n        baseIdList: baseIds,\r\n        size: meta.size,\r\n        crc: meta.crc,\r\n        fileType: type\r\n      };\r\n    });\r\n    fileList[0] = {\r\n      mftId: 0,\r\n      baseIdList: [],\r\n      size: 0,\r\n      crc: 0,\r\n      fileType: \"Non-Registered\"\r\n    };\r\n    return fileList;\r\n  }\r\n\r\n  /**\r\n   * @returns {Array<Array<number>>}\r\n   */\r\n  getReverseIndex() {\r\n    return this._indexTable.reduce((reversed, mftId, baseId) => {\r\n      if (mftId in reversed) reversed[mftId].push(baseId);\r\n      else reversed[mftId] = [baseId];\r\n      return reversed;\r\n    }, []);\r\n  }\r\n\r\n  // API Compatibility\r\n\r\n  /**\r\n     * Looks up mft indices for all mapc pack files in the dat. Either looks trough all files or\r\n     * only the list defined in {@link MapFileList}\r\n     *\r\n     * @deprecated Use now the getFileList method.\r\n     * @param  {boolean}   searchAll if true forces re-indexing of entire dat.\r\n     * If false only reads indices specified in \"T3D/MapFileList\".\r\n     * @param  {Function} callback Fired when the list is generated\r\n     *\r\n     * First argument is the a list of mft indices grouped by file type. For exmample:\r\n     *\r\n     * \t\t{\r\n     * \t\t\tmaps:[\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Heart of Maguuma',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\r\n     * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t},\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Unknown maps',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t}\r\n     * \t\t\t]\r\n\r\n    *\t    };\r\n    */\r\n  readMapListAsync(searchAll, callback) {\r\n    let self = this;\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.readMapListAsync is deprecated !\"\r\n    );\r\n\r\n    // Let's preserve the old output way\r\n    function restoreOuput(array) {\r\n      let returnArray = [];\r\n      for (let elt of array) {\r\n        let category = returnArray.findIndex(i => i.name === elt.category);\r\n        if (category === -1) {\r\n          category = returnArray.push({ name: elt.category, maps: [] }) - 1;\r\n        }\r\n        returnArray[category].maps.push({\r\n          fileName: elt.baseId,\r\n          name: elt.name\r\n        });\r\n      }\r\n      // And resort it in order\r\n      returnArray.sort((i, j) => {\r\n        if (i.name < j.name) return -1;\r\n        if (i.name > j.name) return 1;\r\n        return 0;\r\n      });\r\n      return { maps: returnArray };\r\n    }\r\n\r\n    /// If seachAll flag is true, force a deep search\r\n    if (searchAll) {\r\n      this.readFileList().then(() => {\r\n        callback(restoreOuput(self.getMapList()));\r\n      });\r\n    } else {\r\n      callback(restoreOuput(self.getMapList()));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads the file type of each file in the dat and stores the resulting list in\r\n   * the browser's local storage.\r\n   *\r\n   * @deprecated Use now the readFileList or getFileList methods.\r\n   * @param  {Function} callback Fired when the list is generated and stores\r\n   *\r\n   * First argument is the a list of mft indices grouped by file type.\r\n   */\r\n  readFileListAsync(callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.readFileListAsync is deprecated !\"\r\n    );\r\n\r\n    // Because the API changed we reform the data as wanted previously\r\n    this.readFileList().then(result => {\r\n      let returnObj = {};\r\n      for (let fileEntry of result) {\r\n        if (returnObj[fileEntry.fileType] === undefined) {\r\n          returnObj[fileEntry.fileType] = [];\r\n        }\r\n        returnObj[fileEntry.fileType].push(fileEntry.mftId);\r\n      }\r\n      callback(returnObj);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads data from a file in the dat.\r\n   *\r\n   * @deprecated Use now the Promise-based method readFile.\r\n   * @param  {Number}   baseId   Base or File id of the texture to load\r\n   * @param  {Function} callback Fires when the inflater has read the data.\r\n   *\r\n   * The passed arguments are\r\n   * -ArrayBuffer raw data\r\n   * -Number DXT Type if applicable\r\n   * -Number image width if applicable\r\n   * -Number image height if applicable\r\n   *\r\n   *\r\n   * @param  {boolean}  isImage\r\n   * @param  {boolean}   raw      If true, any infation is skipped and raw data is returned.\r\n   */\r\n  loadFile(baseId, callback, isImage, raw) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadFile is deprecated !\"\r\n    );\r\n    let mftId = this.getFileIndex(baseId);\r\n    if (mftId <= 0) return callback(null);\r\n    this.readFile(mftId, isImage, raw).then(result => {\r\n      if (result.buffer === undefined) return callback(null);\r\n      callback(\r\n        result.buffer,\r\n        result.dxtType,\r\n        result.imageWidth,\r\n        result.imageHeight\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads a bitmap from a texture file in the dat.\r\n   *\r\n   * @deprecated\r\n   * @param  {Number}   baseId   Base or File id of the texture to load\r\n   * @param  {Function} callback Fires when the inflater has read the texture data.\r\n   *\r\n   * The passed arguments are\r\n   * -ArrayBuffer Bitmap\r\n   * -Number DXT Type\r\n   * -Number image width\r\n   * -Number image height\r\n   *\r\n   */\r\n  loadTextureFile(baseId, callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadTextureFile is deprecated !\"\r\n    );\r\n\r\n    this.loadFile(baseId, callback, true);\r\n  }\r\n\r\n  /**\r\n   * Used to read the cached list of files corresponding to the reader's .dat from the localStorage.\r\n   * Now kept only for backward compatibility, but doesn't do anything.\r\n   * Please use getFileList now.\r\n   *\r\n   * @deprecated\r\n   */\r\n  loadFileList() {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadFileList is deprecated !\"\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Used to read the cached list of maps corresponding to the reader's .dat from the localStorage.\r\n   * Now kept only for backward compatibility, but doesn't do anything.\r\n   * Please use getMapList now.\r\n   *\r\n   * @deprecated\r\n   */\r\n  loadMapList() {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadMapList is deprecated !\"\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  // Private\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} baseId\r\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\r\n   * @returns {{scan: boolean, change: string }}\r\n   */\r\n  _needsScan(baseId, persistantData) {\r\n    if (baseId <= 0) return { change: \"none\", scan: false };\r\n\r\n    let mftId = this.getFileIndex(baseId);\r\n    let metaData = this.getFileMeta(mftId);\r\n\r\n    // Nothing interesting\r\n    if (metaData === undefined && !(baseId in persistantData)) {\r\n      return { change: \"none\", scan: false };\r\n    }\r\n    // If the file have been deleted\r\n    else if (metaData === undefined) {\r\n      return { change: \"removed\", scan: false };\r\n    }\r\n    // If the file is new\r\n    else if (!(baseId in persistantData)) {\r\n      return { change: \"added\", scan: true };\r\n    }\r\n    // If the size or crc don't match\r\n    else if (\r\n      metaData.size !== persistantData[baseId].size ||\r\n      metaData.crc !== persistantData[baseId].crc\r\n    ) {\r\n      return { change: \"modified\", scan: true };\r\n    }\r\n    // If everything is the same\r\n    else {\r\n      return { change: \"none\", scan: false };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} baseId\r\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\r\n   * @returns {Promise<{fileType: string, crc: number, size: number}>}\r\n   */\r\n  async _readFileType(baseId) {\r\n    if (!this._fileTypeCache) this._fileTypeCache = [];\r\n\r\n    let mftId = this.getFileIndex(baseId);\r\n    let metaData = this.getFileMeta(mftId);\r\n\r\n    let fileType;\r\n    if (this._fileTypeCache[baseId] !== undefined) {\r\n      fileType = this._fileTypeCache[baseId];\r\n    } else {\r\n      let fileBuffer = (await this.readFile(\r\n        mftId,\r\n        false,\r\n        false,\r\n        Math.min(metaData.size, 1000),\r\n        32\r\n      )).buffer;\r\n      if (fileBuffer === undefined) return undefined;\r\n      fileType = FileTypes.getFileType(new DataStream(fileBuffer));\r\n    }\r\n    return { fileType: fileType, crc: metaData.crc, size: metaData.size };\r\n  }\r\n}\r\n\r\nmodule.exports = LocalReader;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/// Indexed DB versioning\r\nconst DB_VERSION = 4;\r\n\r\n/**\r\n * This class handles offline storage of the .dat indexes and files metadata\r\n * @class PersistantStore\r\n */\r\nclass PersistantStore {\r\n  constructor() {\r\n    // They may be multiple connection request issued at the same time, but it's actually okay since\r\n    // as soon as they are registered, the not-used ones will get garbage collected\r\n    this._dbConnection = undefined;\r\n    this._getConnection(() => {});\r\n  }\r\n\r\n  /**\r\n   *   Initialize the IndexedDB connection and manages version changes.\r\n   *\r\n   * @async\r\n   * @private\r\n   * @returns {Promise<IDBDatabase>} Promise to the Database connection\r\n   */\r\n  _getConnection() {\r\n    let self = this;\r\n    return new Promise((resolve, reject) => {\r\n      if (self._dbConnection) resolve(self._dbConnection);\r\n\r\n      // Let us open our database\r\n      let request = window.indexedDB.open(\"Tyria3DLibrary\", DB_VERSION);\r\n\r\n      /// onblocked is fired when the db needs an upgrade but an older version is opened in another tab\r\n      request.onblocked = () => {\r\n        T3D.Logger.log(\r\n          T3D.Logger.TYPE_ERROR,\r\n          \"The T3D persistant database cannot be upgraded while the app is opened somewhere else.\"\r\n        );\r\n      };\r\n\r\n      /// fired when the database needs to be upgraded (or the first time)\r\n      request.onupgradeneeded = event => {\r\n        /** @type {IDBDatabase} */\r\n        let db = event.target.result;\r\n        let currentVersion = event.oldVersion;\r\n\r\n        if (currentVersion < 2) {\r\n          db.createObjectStore(\"listings\", {\r\n            autoIncrement: true\r\n          });\r\n        }\r\n\r\n        if (currentVersion < 3) {\r\n          let storeListing = event.currentTarget.transaction.objectStore(\r\n            \"listings\"\r\n          );\r\n          storeListing.createIndex(\"filename\", \"filename\", { unique: false });\r\n        }\r\n      };\r\n\r\n      request.onsuccess = event => {\r\n        self._dbConnection = event.target.result;\r\n        self.isReady = true;\r\n        resolve(self._dbConnection);\r\n      };\r\n\r\n      request.onerror = () => {\r\n        T3D.Logger.log(\r\n          T3D.Logger.TYPE_ERROR,\r\n          \"The T3D persistant database could not be opened.\"\r\n        );\r\n        reject();\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   *   Add or update a listing into the database\r\n   *\r\n   * @async\r\n   * @param {number|undefined} id This ID doesn't really matter, it's just the index of the object in the database, can be undefined\r\n   * @param {Array} listing\r\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\r\n   * @param {boolean} isComplete Keep back the information if that was the last update on the current scan or not.\r\n   * @returns {Promise<number>} On success, the number is the object key in the database\r\n   */\r\n  putListing(id, listing, fileName, isComplete) {\r\n    let self = this;\r\n    return new Promise((resolve, reject) => {\r\n      self._getConnection().then(db => {\r\n        let store = db\r\n          .transaction([\"listings\"], \"readwrite\")\r\n          .objectStore(\"listings\");\r\n\r\n        let request = id\r\n          ? store.put(\r\n              { array: listing, filename: fileName, complete: isComplete },\r\n              id\r\n            )\r\n          : store.put({ array: listing, name: fileName });\r\n\r\n        request.onsuccess = () => {\r\n          resolve(request.result);\r\n        };\r\n        request.onerror = () => {\r\n          reject();\r\n        };\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the last valid listing in the database\r\n   *\r\n   * @async\r\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\r\n   * @returns {Promise<{array: Array, key: number, complete: boolean}>}\r\n   *      array: the last listing\r\n   *      key: the index of the last listing in the database\r\n   */\r\n  getLastListing(fileName) {\r\n    let self = this;\r\n    return new Promise(resolve => {\r\n      self._getConnection().then(db => {\r\n        let listingsStore = db\r\n          .transaction([\"listings\"], \"readonly\")\r\n          .objectStore(\"listings\")\r\n          .index(\"filename\");\r\n\r\n        listingsStore.openCursor(\r\n          IDBKeyRange.only(fileName),\r\n          \"prev\"\r\n        ).onsuccess = event => {\r\n          let cursor = event.target.result;\r\n          if (!cursor) resolve({ array: [], key: undefined, complete: true });\r\n          else {\r\n            resolve({\r\n              array: cursor.value.array,\r\n              key: cursor.primaryKey,\r\n              complete: cursor.value.complete\r\n            });\r\n          }\r\n        };\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = PersistantStore;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/**\r\n * A Logger class for T3D\r\n *\r\n * This satic class defines severity levels of messages and provides\r\n * basic logging functionality. Replacing the reference to\r\n *\r\n * @namespace\r\n * @static\r\n */\r\nlet Logger = {};\r\n\r\n/**\r\n * @readonly\r\n * @property {number} TYPE_ERROR\r\n */\r\nLogger.TYPE_ERROR = 4;\r\n\r\n/**\r\n * @readonly\r\n * @property {number} TYPE_WARNING\r\n */\r\nLogger.TYPE_WARNING = 3;\r\n\r\n/**\r\n * @readonly\r\n * @property {number} TYPE_MESSAGE\r\n */\r\nLogger.TYPE_MESSAGE = 2;\r\n\r\n/**\r\n * @readonly\r\n * @property {number} TYPE_PROGRESS\r\n */\r\nLogger.TYPE_PROGRESS = 1;\r\n\r\n/**\r\n * @readonly\r\n * @property {number} TYPE_DEBUG\r\n */\r\nLogger.TYPE_DEBUG = 0;\r\n\r\n/**\r\n * The logging functions, indexed by severity/type.\r\n *\r\n * @property logFunctions\r\n * @type Function[]\r\n */\r\nLogger.logFunctions = new Array(5);\r\n\r\n/**\r\n * Main logging method. Takes 1 to N arguments. If there are more than 1 arguments\r\n * the first argument is interpreted as severity. If there is only one argument\r\n * severity defaults to\r\n * {{#crossLink \"Logger/TYPE_MESSAGE:property\"}}{{/crossLink}}.\r\n *\r\n * The following arguments are passed to a logging function matching the\r\n * severity.\r\n *\r\n\r\n *\r\n */\r\nLogger.log = function() {\r\n  /// Require at least 1 argument\r\n  if (arguments.length === 0) {\r\n    return;\r\n  }\r\n\r\n  /// Parse arguments to an actual array\r\n  let argArr = Logger.argsToArr(arguments);\r\n\r\n  /// Default to message if just one argument was passed\r\n  if (argArr.length === 1) {\r\n    argArr.unshift(Logger.TYPE_MESSAGE);\r\n  }\r\n\r\n  /// Otherwise 1st arg is severity, log/warn/error\r\n  let severity = Math.max(\r\n    0,\r\n    Math.min(Logger.logFunctions.length, argArr.shift())\r\n  );\r\n  let logFunc = Logger.logFunctions[severity];\r\n\r\n  /// Ouput the rest of the arguments\r\n  logFunc.apply(this, argArr);\r\n};\r\n\r\nLogger.argsToArr = function(args) {\r\n  let argArr = new Array(args.length);\r\n  for (let i = 0; i < argArr.length; ++i) {\r\n    argArr[i] = args[i];\r\n  }\r\n  return argArr;\r\n};\r\n\r\nLogger.logFunctions[Logger.TYPE_ERROR] = function() {\r\n  console.error.apply(console, arguments);\r\n};\r\n\r\nLogger.logFunctions[Logger.TYPE_WARNING] = function() {\r\n  console.warn.apply(console, arguments);\r\n};\r\n\r\nLogger.logFunctions[Logger.TYPE_MESSAGE] = function() {\r\n  console.log.apply(console, arguments);\r\n};\r\n\r\nLogger.logFunctions[Logger.TYPE_PROGRESS] = function() {\r\n  let argArr = Logger.argsToArr(arguments);\r\n  argArr.unshift(\"Progress: \");\r\n  console.log.apply(console, argArr);\r\n};\r\n\r\nLogger.logFunctions[Logger.TYPE_DEBUG] = function() {\r\n  let argArr = Logger.argsToArr(arguments);\r\n  console.debug.apply(console, argArr);\r\n};\r\n\r\nmodule.exports = Logger;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nmodule.exports = {\r\n  /**\r\n   * @property maps\r\n   * @type {Array.<{name: String, maps: Array.<{fileName: String, name: String}>}>}\r\n   */\r\n  maps: [\r\n    {\r\n      name: \"01. Shiverpeaks\",\r\n      maps: [\r\n        { fileName: \"125199.data\", name: \"Wayfarer Foothills (0)\" },\r\n        { fileName: \"187611.data\", name: \"Wayfarer Foothills (1)\" },\r\n        { fileName: \"568778.data\", name: \"Cragstead\" },\r\n        { fileName: \"132434.data\", name: \"Hoelbrak (0)\" },\r\n        { fileName: \"197122.data\", name: \"Hoelbrak (1)\" },\r\n        { fileName: \"1966018.data\", name: \"Hoelbrak (2)\" },\r\n        { fileName: \"124093.data\", name: \"Snowden Drifts (0)\" },\r\n        { fileName: \"186397.data\", name: \"Snowden Drifts (1)\" },\r\n        { fileName: \"275155.data\", name: \"Dredgehaunt Cliffs\" },\r\n        { fileName: \"276252.data\", name: \"Frostgorge Sound\" },\r\n        { fileName: \"277587.data\", name: \"Lornar's Pass\" },\r\n        { fileName: \"278717.data\", name: \"Timberline Falls (0)\" },\r\n        { fileName: \"846866.data\", name: \"Timberline Falls (1)\" },\r\n        { fileName: \"1018612.data\", name: \"Timberline Falls (2)\" },\r\n        { fileName: \"295282.data\", name: \"Eye of the North\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"02. Ascalon\",\r\n      maps: [\r\n        { fileName: \"126118.data\", name: \"Plains of Ashford (0)\" },\r\n        { fileName: \"188591.data\", name: \"Plains of Ashford (1)\" },\r\n        { fileName: \"127888.data\", name: \"Diessa Plateau (0)\" },\r\n        { fileName: \"190490.data\", name: \"Diessa Plateau (1)\" },\r\n        { fileName: \"131944.data\", name: \"Black Citadel (0)\" },\r\n        { fileName: \"196585.data\", name: \"Black Citadel (1)\" },\r\n        { fileName: \"1968107.data\", name: \"Black Citadel (2)\" },\r\n        { fileName: \"280025.data\", name: \"Blazeridge Steppes\" },\r\n        { fileName: \"281313.data\", name: \"Fireheart Rise\" },\r\n        { fileName: \"282668.data\", name: \"Iron Marches\" },\r\n        { fileName: \"283574.data\", name: \"Fields of Ruin\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"03. Kryta\",\r\n      maps: [\r\n        { fileName: \"191000.data\", name: \"Lion's Arch (0)\" },\r\n        { fileName: \"814803.data\", name: \"Lion's Arch (1)\" },\r\n        { fileName: \"1019669.data\", name: \"Lion's Arch (Legacy)\" },\r\n        { fileName: \"1796999.data\", name: \"Lion's Arch (2)\" },\r\n        { fileName: \"1869665.data\", name: \"Lion's Arch (3)\" },\r\n        { fileName: \"1968576.data\", name: \"Lion's Arch (4)\" },\r\n        { fileName: \"128151.data\", name: \"Divinity's Reach (0)\" },\r\n        { fileName: \"191265.data\", name: \"Divinity's Reach (1)\" },\r\n        { fileName: \"705746.data\", name: \"Divinity's Reach (2)\" },\r\n        { fileName: \"1968748.data\", name: \"Divinity's Reach (3)\" },\r\n        { fileName: \"129834.data\", name: \"North of Divinity's Reach (0)\" },\r\n        { fileName: \"193081.data\", name: \"North of Divinity's Reach (1)\" },\r\n        { fileName: \"129524.data\", name: \"Queensdale (0)\" },\r\n        { fileName: \"192711.data\", name: \"Queensdale (1)\" },\r\n        { fileName: \"130970.data\", name: \"Kessex Hills (0)\" },\r\n        { fileName: \"194288.data\", name: \"Kessex Hills (1)\" },\r\n        { fileName: \"672138.data\", name: \"Kessex Hills (2)\" },\r\n        { fileName: \"861815.data\", name: \"Kessex Hills (3)\" },\r\n        { fileName: \"286945.data\", name: \"Bloodtide Coast\" },\r\n        { fileName: \"287870.data\", name: \"Harathi Hinterlands\" },\r\n        { fileName: \"289176.data\", name: \"Gendarran Fields\" },\r\n        { fileName: \"295005.data\", name: \"Chantry of Secrets\" },\r\n        { fileName: \"294938.data\", name: \"Claw Island\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"04. Maguuma Jungle\",\r\n      maps: [\r\n        { fileName: \"195149.data\", name: \"Caledon Forest\" },\r\n        { fileName: \"195493.data\", name: \"Metrica Province\" },\r\n        { fileName: \"922320.data\", name: \"Metrica Province Instance\" },\r\n        { fileName: \"198076.data\", name: \"The Grove (0)\" },\r\n        { fileName: \"1969341.data\", name: \"The Grove (1)\" },\r\n        { fileName: \"198272.data\", name: \"Rata Sum (0)\" },\r\n        { fileName: \"1968896.data\", name: \"Rata Sum (1)\" },\r\n        { fileName: \"291064.data\", name: \"Mount Maelstrom\" },\r\n        { fileName: \"292254.data\", name: \"Sparkfly Fen\" },\r\n        { fileName: \"293307.data\", name: \"Brisban Wildlands\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"05. Ruins of Orr\",\r\n      maps: [\r\n        { fileName: \"284829.data\", name: \"Straits of Devastation\" },\r\n        { fileName: \"285089.data\", name: \"Malchor's Leap\" },\r\n        { fileName: \"285634.data\", name: \"Cursed Shore\" },\r\n        { fileName: \"295179.data\", name: \"Cathedral of Hidden Depths\" },\r\n        { fileName: \"295962.data\", name: \"A Light in the Darkness\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"06. Living World S1\",\r\n      maps: [\r\n        { fileName: \"520479.data\", name: \"Southsun Cove\" },\r\n        { fileName: \"679089.data\", name: \"Tower of Nightmares\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"07. Living World S2\",\r\n      maps: [\r\n        { fileName: \"836211.data\", name: \"Dry top (0)\" },\r\n        { fileName: \"861770.data\", name: \"Dry top (1)\" },\r\n        { fileName: \"909361.data\", name: \"The Silverwastes (0)\" },\r\n        { fileName: \"996202.data\", name: \"The Silverwastes (1)\" },\r\n        { fileName: \"908730.data\", name: \"Glint's Lair\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"08. Heart of Maguuma\",\r\n      maps: [\r\n        { fileName: \"969663.data\", name: \"Verdant Brink\" },\r\n        { fileName: \"1262460.data\", name: \"Hearts and Minds\" },\r\n        { fileName: \"969964.data\", name: \"Unknown Airship in tree\" },\r\n        { fileName: \"1262310.data\", name: \"Dragon Stand\" },\r\n        { fileName: \"1263739.data\", name: \"Tarir\" },\r\n        { fileName: \"1264291.data\", name: \"Tangled Depths\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"09. Living World S3\",\r\n      maps: [\r\n        { fileName: \"1472635.data\", name: \"(E1) Bloodstone Fen\" },\r\n        { fileName: \"1498071.data\", name: \"(E2) Taimi Simulator\" },\r\n        { fileName: \"1498578.data\", name: \"(E2) Ring of Fire\" },\r\n        { fileName: \"1605211.data\", name: \"(E3) Bitterfrost Frontier\" },\r\n        { fileName: \"1645474.data\", name: \"(E4) Caudecus Manor\" },\r\n        { fileName: \"1646520.data\", name: \"(E4) Lake Doric\" },\r\n        { fileName: \"1682493.data\", name: \"(E5) Draconis Mons\" },\r\n        { fileName: \"1682763.data\", name: \"(E5) Titan's Throat\" },\r\n        { fileName: \"1734839.data\", name: \"(E6) White Mantle Fortress\" },\r\n        { fileName: \"1735346.data\", name: \"(E6) Siren's Landing\" },\r\n        { fileName: \"1735440.data\", name: \"(E6) Shining Blade Headquarters\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"10. Crystal Desert\",\r\n      maps: [\r\n        { fileName: \"1794574.data\", name: \"Crystal Oasis\" },\r\n        { fileName: \"1833034.data\", name: \"Desert Highlands\" },\r\n        { fileName: \"1833726.data\", name: \"PoF story instances\" },\r\n        { fileName: \"1839188.data\", name: \"Domain of Vabbi\" },\r\n        { fileName: \"1840103.data\", name: \"Elon Riverlands\" },\r\n        { fileName: \"1840368.data\", name: \"Kormir Sanctuary\" },\r\n        { fileName: \"1842533.data\", name: \"The Desolation\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"11. Living World S4\",\r\n      maps: [\r\n        { fileName: \"1901428.data\", name: \"(E1) Fahranur\" },\r\n        { fileName: \"1902235.data\", name: \"(E1) Istan\" },\r\n        { fileName: \"1903523.data\", name: \"(E1) Crystal Oasis\" },\r\n        { fileName: \"1954984.data\", name: \"(E2) Desert Highlands\" },\r\n        { fileName: \"1955224.data\", name: \"(E2) Inquest Lab Tower\" },\r\n        { fileName: \"1955471.data\", name: \"(E2) Rata Primus\" },\r\n        { fileName: \"1955642.data\", name: \"(E2) Divinity's Reach\" },\r\n        { fileName: \"1955915.data\", name: \"(E2) Mount Maelstrom\" },\r\n        { fileName: \"1956140.data\", name: \"(E2) Frostgorge Sound\" },\r\n        { fileName: \"1956245.data\", name: \"(E2) Void\" },\r\n        { fileName: \"1956299.data\", name: \"(E2) Hided Inquest Lab\" },\r\n        { fileName: \"1957526.data\", name: \"(E2) Sandswept Isles\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"12. Seasonal Activities\",\r\n      maps: [\r\n        { fileName: \"506592.data\", name: \"Ascent to Madness\" },\r\n        { fileName: \"506670.data\", name: \"Mad King's Labyrinth (Past)\" },\r\n        { fileName: \"662436.data\", name: \"Mad King's Labyrinth (Present)\" },\r\n        { fileName: \"506739.data\", name: \"Mad King's Clock Tower\" },\r\n        { fileName: \"622681.data\", name: \"The Crown Pavilion\" },\r\n        { fileName: \"569756.data\", name: \"SAB Hub (0)\" },\r\n        { fileName: \"636133.data\", name: \"SAB Hub (1)\" },\r\n        { fileName: \"635555.data\", name: \"SAB World 1\" },\r\n        { fileName: \"635960.data\", name: \"SAB World 2\" },\r\n        { fileName: \"606255.data\", name: \"Zephyr Sanctum\" },\r\n        { fileName: \"529896.data\", name: \"Tixx's Infinirarium\" },\r\n        { fileName: \"529945.data\", name: \"Winter Wonderland\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"13. Activites\",\r\n      maps: [\r\n        { fileName: \"605983.data\", name: \"Sanctum Sprint\" },\r\n        { fileName: \"606030.data\", name: \"Basket Brawl\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"14. Dungeons\",\r\n      maps: [\r\n        { fileName: \"126840.data\", name: \"Ascalonian Catacombs (0)\" },\r\n        { fileName: \"189364.data\", name: \"Ascalonian Catacombs (1)\" },\r\n        { fileName: \"275474.data\", name: \"Sorrow's Embrace\" },\r\n        { fileName: \"276520.data\", name: \"Honor of the Waves\" },\r\n        { fileName: \"284039.data\", name: \"Citadel of Flame\" },\r\n        { fileName: \"287214.data\", name: \"Caudecus's Manor\" },\r\n        { fileName: \"291284.data\", name: \"Twilight Arbor (0)\" },\r\n        { fileName: \"645968.data\", name: \"Twilight Arbor (1)\" },\r\n        { fileName: \"293606.data\", name: \"Crucible of Eternity\" },\r\n        { fileName: \"473930.data\", name: \"The Ruined City of Arah\" },\r\n        { fileName: \"473765.data\", name: \"Arah - Story\" },\r\n        { fileName: \"580061.data\", name: \"Molten Facility\" },\r\n        { fileName: \"595722.data\", name: \"Aetherblade Retreat\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"15. Fractals\",\r\n      maps: [\r\n        { fileName: \"519839.data\", name: \"Fractals of the Mists\" },\r\n        { fileName: \"697450.data\", name: \"Thaumanova Reactor\" },\r\n        { fileName: \"1426653.data\", name: \"Cliffside Fractal\" },\r\n        { fileName: \"1472361.data\", name: \"Chaos Isle Fractal\" },\r\n        { fileName: \"1472382.data\", name: \"Snowblind Fractal\" },\r\n        { fileName: \"1472406.data\", name: \"Swampland Fractal\" },\r\n        { fileName: \"1498016.data\", name: \"Mistlock Observatory\" },\r\n        { fileName: \"1498798.data\", name: \"Aetherblade/Mai Trin Fractal\" },\r\n        { fileName: \"1605344.data\", name: \"Nightmare Fractal\" },\r\n        { fileName: \"1733857.data\", name: \"Shattered Observatory Fractal\" },\r\n        { fileName: \"1733961.data\", name: \"Mistlock Sanctuary\" },\r\n        { fileName: \"1905739.data\", name: \"Molten Boss Fractal\" },\r\n        { fileName: \"1905889.data\", name: \"Twilight Oasis Fractal\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"16. Raid\",\r\n      maps: [\r\n        { fileName: \"1151420.data\", name: \"(W1) Spirit Vale\" },\r\n        { fileName: \"1383309.data\", name: \"(W2) Salvation Pass\" },\r\n        { fileName: \"1427048.data\", name: \"Special Forces Training Area\" },\r\n        { fileName: \"1454070.data\", name: \"(W3) Stronghold of the Faithful\" },\r\n        { fileName: \"1645215.data\", name: \"(W4) Bastion of the Penitent\" },\r\n        { fileName: \"1906329.data\", name: \"(W5) Hall of Chains\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"17. Structured PvP\",\r\n      maps: [\r\n        { fileName: \"871093.data\", name: \"Original Stronghold\" },\r\n        { fileName: \"870987.data\", name: \"Battle of Champion's Dusk (0)\" },\r\n        { fileName: \"1666233.data\", name: \"Battle of Champion's Dusk (1)\" },\r\n        { fileName: \"132570.data\", name: \"Heart of the Mists (0)\" },\r\n        { fileName: \"197249.data\", name: \"Heart of the Mists (1)\" },\r\n        { fileName: \"1734729.data\", name: \"Heart of the Mists (2)\" },\r\n        { fileName: \"1712986.data\", name: \"Hall of the Mists\" },\r\n        { fileName: \"132710.data\", name: \"The Battle of Khylo (0)\" },\r\n        { fileName: \"197402.data\", name: \"The Battle of Khylo (1)\" },\r\n        { fileName: \"132837.data\", name: \"Forest of Niflhel (0)\" },\r\n        { fileName: \"197545.data\", name: \"Forest of Niflhel (1)\" },\r\n        { fileName: \"376916.data\", name: \"Legacy of the Foefire\" },\r\n        { fileName: \"467374.data\", name: \"Raid on the Capricorn\" },\r\n        { fileName: \"520609.data\", name: \"Temple of the Silent Storm\" },\r\n        { fileName: \"579383.data\", name: \"Skyhammer (0)\" },\r\n        { fileName: \"677968.data\", name: \"Skyhammer (1)\" },\r\n        { fileName: \"1934470.data\", name: \"Skyhammer (2)\" },\r\n        { fileName: \"791564.data\", name: \"Courtyard (0)\" },\r\n        { fileName: \"1713054.data\", name: \"Courtyard (1)\" },\r\n        { fileName: \"556199.data\", name: \"Spirit Watch (0)\" },\r\n        { fileName: \"1473061.data\", name: \"Spirit Watch (1)\" },\r\n        { fileName: \"506539.data\", name: \"Reaper's Rumble\" },\r\n        { fileName: \"529718.data\", name: \"Snowball Mayhem\" },\r\n        { fileName: \"595582.data\", name: \"Dragon Ball Arena\" },\r\n        { fileName: \"617120.data\", name: \"Aspect Arena\" },\r\n        { fileName: \"1644624.data\", name: \"Revenge of the Capricorn\" },\r\n        { fileName: \"1704155.data\", name: \"Eternal Coliseum\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"18. World vs World\",\r\n      maps: [\r\n        { fileName: \"131235.data\", name: \"Eternal Battlegrounds (0)\" },\r\n        { fileName: \"195806.data\", name: \"Eternal Battlegrounds (1)\" },\r\n        { fileName: \"1885693.data\", name: \"Eternal Battlegrounds (2)\" },\r\n        { fileName: \"1918037.data\", name: \"Eternal Battlegrounds (3)\" },\r\n        { fileName: \"131574.data\", name: \"Alpine Borderlands (0)\" },\r\n        { fileName: \"641501.data\", name: \"Alpine Borderlands (1)\" },\r\n        { fileName: \"1799855.data\", name: \"Alpine Borderlands (2)\" },\r\n        { fileName: \"1647236.data\", name: \"Desert Borderlands (0)\" },\r\n        { fileName: \"1799442.data\", name: \"Desert Borderlands (1)\" },\r\n        { fileName: \"736241.data\", name: \"Edge of the Mists\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"19. Guild Halls\",\r\n      maps: [\r\n        { fileName: \"1255378.data\", name: \"Gilded Hollow\" },\r\n        { fileName: \"1256064.data\", name: \"Lost Precipice\" },\r\n        { fileName: \"1843274.data\", name: \"Windswept Haven\" }\r\n      ]\r\n    },\r\n    {\r\n      name: \"20. Concept and not released\",\r\n      maps: [\r\n        { fileName: \"122695.data\", name: \"Empty Plane\" },\r\n        { fileName: \"184799.data\", name: \"Empty Plane v1\" },\r\n        { fileName: \"197562.data\", name: \"Empty Plane v2\" },\r\n        { fileName: \"875614.data\", name: \"Unknown Mists Platforms\" },\r\n        { fileName: \"132853.data\", name: \"Empty Box\" },\r\n        { fileName: \"1255516.data\", name: \"Guild Coliseum\" },\r\n        { fileName: \"1498193.data\", name: \"Concept sPVP Map 1\" },\r\n        { fileName: \"1513556.data\", name: \"Concept sPVP Map 2\" },\r\n        { fileName: \"1513607.data\", name: \"Concept sPVP Map 3\" },\r\n        { fileName: \"1513620.data\", name: \"Concept sPVP Map 4\" },\r\n        { fileName: \"1513675.data\", name: \"Concept sPVP Map 5\" },\r\n        { fileName: \"1712945.data\", name: \"Concept sPVP Map 6\" }\r\n      ]\r\n    }\r\n  ]\r\n};\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/* INCLUDES */\r\nlet LocalReader = require(\"./LocalReader/LocalReader\");\r\n\r\n/* PRIVATE VARS */\r\nlet _version = \"1.1.0\";\r\nlet _settings = {\r\n  t3dtoolsWorker: \"modules/t3dtools/t3dworker.js\",\r\n  concurrentTasks:\r\n    typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency : 1\r\n};\r\n\r\nlet T3D;\r\n\r\n/* PUBLIC PROPERTIES */\r\n\r\n/**\r\n * Tyria 3D Library main module.\r\n *\r\n * Use this static class to access file parsers- and data renderer classes.\r\n *\r\n * This class also works as a factory for creating\r\n * LocalReader instances that looks up and inflates files from the Guild Wars 2 .dat.\r\n * @module T3D\r\n */\r\nT3D = module.exports = {\r\n  /**\r\n   * The current library version. Used to make sure local storage caches are not\r\n   * shared between different releases.\r\n   *\r\n   * @property version\r\n   * @type String\r\n   */\r\n  version: _version,\r\n\r\n  /* FILES */\r\n\r\n  /**\r\n   * A static reference to the GW2File class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @memberof T3D\r\n   * @property GW2File\r\n   * @type Class\r\n   */\r\n  GW2File: require(\"./format/file/GW2File\"),\r\n\r\n  /**\r\n   * A static reference to the GW2Chunk class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @memberOf T3D\r\n   * @property GW2Chunk\r\n   * @type Class\r\n   */\r\n  GW2Chunk: require(\"./format/file/GW2Chunk\"),\r\n\r\n  /* RENDERERS */\r\n\r\n  /**\r\n   * A static reference to the DataRenderer class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @readonly\r\n   * @property DataRenderer\r\n   * @type Class\r\n   */\r\n  DataRenderer: require(\"./dataRenderer/DataRenderer\"),\r\n\r\n  /**\r\n   * A static reference to the EnvironmentRenderer class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @readonly\r\n   * @property EnvironmentRenderer\r\n   * @type Class\r\n   */\r\n  EnvironmentRenderer: require(\"./dataRenderer/EnvironmentRenderer\"),\r\n\r\n  /**\r\n   * A static reference to the HavokRenderer class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @readonly\r\n   * @property HavokRenderer\r\n   * @type Class\r\n   */\r\n  HavokRenderer: require(\"./dataRenderer/HavokRenderer\"),\r\n\r\n  /**\r\n   * A static reference to the PropertiesRenderer class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @readonly\r\n   * @property PropertiesRenderer\r\n   * @type Class\r\n   */\r\n  PropertiesRenderer: require(\"./dataRenderer/PropertiesRenderer\"),\r\n\r\n  /**\r\n   * A static reference to the SingleModelRenderer class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @readonly\r\n   * @property SingleModelRenderer\r\n   * @type Class\r\n   */\r\n  SingleModelRenderer: require(\"./dataRenderer/SingleModelRenderer\"),\r\n\r\n  /**\r\n   * A static reference to the TerrainRenderer class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @readonly\r\n   * @property TerrainRenderer\r\n   * @type Class\r\n   */\r\n  TerrainRenderer: require(\"./dataRenderer/TerrainRenderer\"),\r\n\r\n  /**\r\n   * A static reference to the ZoneRenderer class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @readonly\r\n   * @property ZoneRenderer\r\n   * @type Class\r\n   */\r\n  ZoneRenderer: require(\"./dataRenderer/ZoneRenderer\"),\r\n\r\n  /**\r\n   * A static reference to the StringRenderer class, the preferred way of\r\n   * accessing this class.\r\n   *\r\n   * @readonly\r\n   * @property StringRenderer\r\n   * @type Class\r\n   */\r\n  StringRenderer: require(\"./dataRenderer/StringRenderer\"),\r\n\r\n  /* LOGGING */\r\n\r\n  /**\r\n   * A static reference to the static Logger object, the preferred way of\r\n   * accessing this object. A simple way of providing your own logging methods\r\n   * is to simply overwrite any or all of the logging methods specified in\r\n   * {{#crossLink \"Logger/logFunctions:property\"}}{{/crossLink}}\r\n   *\r\n   * @property Logger\r\n   * @type Object\r\n   */\r\n  Logger: require(\"./Logger\"),\r\n\r\n  /* SETTINGS */\r\n\r\n  /**\r\n   * Contains a list of known map fileID:s and their names. Used in order to quickly\r\n   * look up what maps are in a .dat file. Note that this property is hard coded and\r\n   * has high probablity of being outdated. Also note that the names are just guesses\r\n   * by RequestTimeout.\r\n   *\r\n   * The format of this list objects is\r\n   *\r\n   *\r\n   * \t{\r\n   *  \tmaps : [\r\n   *\t  \t\t{\r\n   *     \t\t\tname:\"World Area Name\",\r\n   *\t       \t\tmaps:[\r\n   *\t         \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name One\" },\r\n   *\t           \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name Two\" },\r\n   *\t             \t{ fileName :\"[numeric fileId].data\", name:\"Map Name Three\" }\r\n   *\t              ]\r\n   *           },\r\n   *\t         {\r\n   *\t\t\t    name:\"Another World Area Name\",\r\n   *\t\t \t   \tmaps:[\r\n   *\t\t \t\t   \t{ fileName :\"[numeric fileId].data\", name:\"Map Name 408\" }\r\n   *\t\t\t    ]\r\n   *\t\t     }\r\n   * \t\t]\r\n   *   }\r\n   *\r\n   * @readonly\r\n   * @property MapFileList\r\n   * @type Object\r\n   */\r\n  MapFileList: require(\"./MapFileList\"),\r\n\r\n  /* UTILS */\r\n\r\n  /**\r\n   * A static reference to the MaterialUtils class.\r\n   *\r\n   * @readonly\r\n   * @property MaterialUtils\r\n   * @type Object\r\n   */\r\n  MaterialUtils: require(\"./util/MaterialUtils.js\"),\r\n\r\n  /**\r\n   * A static reference to the MathUtils class.\r\n   *\r\n   * @readonly\r\n   * @property MathUtils\r\n   * @type Object\r\n   */\r\n  MathUtils: require(\"./util/MathUtils.js\"),\r\n\r\n  /**\r\n   * A static reference to the ParserUtils class.\r\n   *\r\n   * @readonly\r\n   * @property ParserUtils\r\n   * @type Object\r\n   */\r\n  ParserUtils: require(\"./util/ParserUtils.js\"),\r\n\r\n  /**\r\n   * A static reference to the RenderUtils class.\r\n   *\r\n   * @readonly\r\n   * @property RenderUtils\r\n   * @type Object\r\n   */\r\n  RenderUtils: require(\"./util/RenderUtils.js\"),\r\n\r\n  /**\r\n   * A static reference to the PersistantStore class.\r\n   *\r\n   * @readonly\r\n   * @property PersistantStore\r\n   * @type Class\r\n   */\r\n  PersistantStore: require(\"./LocalReader/PersistantStore\"),\r\n\r\n  /**\r\n   * A static reference to the FileTypes tools and list.\r\n   *\r\n   * @readonly\r\n   * @property FileTypes\r\n   * @type Object\r\n   */\r\n  FileTypes: require(\"./LocalReader/FileTypes\"),\r\n\r\n  /* PUBLIC METHODS */\r\n\r\n  /**\r\n   * Creates a new instance of LocalReader with an pNaCl inflater connected to it.\r\n   *\r\n   * @async\r\n   * @param  {File}   \tfile\t\tCore JS File instance, must refer to a GW2 .dat file\r\n   * @param  {Function}\tcallback\tCallback function, fired when the file index is fully\r\n   *                             \t\tconstructed. Takes no arguments.\r\n   *\r\n   * @param  {String} \tt3dtoolsWorker URL to the inflater file. If omitted\r\n   *                               \t_settings.t3dtoolsWorker will be used instead.\r\n   *\r\n   * @return {LocalReader}\t\t\tThe contructed LocalReader, note that this object\r\n   *                             \t\twill not be fully initialized until the callback\r\n   *                             \t\tis fired.\r\n   */\r\n  getLocalReader: function(file, callback, t3dtoolsWorker) {\r\n    let path = t3dtoolsWorker || _settings.t3dtoolsWorker;\r\n\r\n    // Create the instance and init the threads\r\n    let lrInstance = new LocalReader({\r\n      workerPath: path,\r\n      workersNb: _settings.concurrentTasks\r\n    });\r\n\r\n    /// Callback with the lrInstance\r\n    lrInstance.openArchive(file).then(() => {\r\n      callback(lrInstance);\r\n    });\r\n\r\n    return lrInstance;\r\n  },\r\n\r\n  /**\r\n   * Utility method for acceccing a list containing information about all files\r\n   * in the .dat connected to the provided LocalReader instance. This method first\r\n   * tries to read a local indexing list from the client's localstorage and\r\n   * fallbacks to generating the list by scanning the MFT indices of the .dat\r\n   * and peeking each file in order to find out what filetype it has.\r\n   *\r\n   * Note that peeking the files is the time consuming task, so if you don't want\r\n   * yout application to spend time indexing the .dat and have a priori knowledge\r\n   * about the required file Id's you should not use this method.\r\n   *\r\n   * @async\r\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\r\n   * @param  {Function}\t\tcallback    Fires when the index has been loaded\r\n   *                                 \t\tfrom the localstorage or after it has\r\n   *                                 \t\tbeen built and stored in localstorage.\r\n   *                                 \t\tTakes the generated object list of\r\n   *                                 \t\tfiles as an argument. This list groups\r\n   *                                 \t\tarrays of MFT indices per file type,\r\n   *                                 \t\tfor exmample:\r\n   *\r\n   *\r\n   * \t{\r\n   *\t  \t\"Unknown\"\t: [444, 555, 333],\r\n   *\t  \t\"MODL\"\t\t: [444, 555, 333],\r\n   * \t  \t\"String\"\t: [666, 777, 888]\r\n   * \t}\r\n   *\r\n   * For more details see\r\n   * {{#crossLink \"LocalReader/listFiles:method\"}}{{/crossLink}}\r\n   */\r\n  getFileListAsync: function(localReader, callback) {\r\n    /// Check local storage for an existing file list\r\n    let fileList = localReader.loadFileList();\r\n\r\n    /// If there is no cached list, look for pre-defined maps.\r\n    if (!fileList) {\r\n      localReader.readFileListAsync(callback);\r\n    }\r\n\r\n    /// Otherwise, just fire the callback with the cached list\r\n    else {\r\n      callback(fileList);\r\n    }\r\n  },\r\n\r\n  /**\r\n\t * Utility method for acceccing a list containing information about all map files\r\n\t * in the .dat connected to the provided LocalReader instance. This method first\r\n\t * tries to read a local indexing list from the client's localstorage and\r\n\t * fallbacks to generating the list by scanning the MFT indices of the .dat\r\n\t * and peeking each file in order to find out what filetype it has.\r\n\t *\r\n\t * If the searchAll flag is not set to true, this process will only scan files\r\n\t * from the {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}\r\n\t *\r\n\t * @async\r\n\t * @param {LocalReader}\tlocalReader\tA fully initialized LocalReader instance\r\n\t * @param {Function}\tcallback\tFires when the index has been loaded\r\n\t *                                 \tfrom the localstorage or after it has\r\n\t *                                 \tbeen built and stored in localstorage.\r\n\t *                                 \tTakes the generated object list of\r\n\t *                                 \tfiles as an argument. This list groups\r\n\t *                                 \tarrays of MFT indices per file type,\r\n\t *                                 \tfor exmample:\r\n\t *\r\n\t * \t\t{\r\n\t * \t\t\tmaps:[\r\n\t * \t\t\t\t{\r\n\t * \t\t\t\t\tname: 'Heart of Maguuma',\r\n\t * \t\t\t\t\tmaps: [\r\n\t * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\r\n\t * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\r\n\t * \t\t\t\t\t]\r\n\t * \t\t\t\t},\r\n\t * \t\t\t\t{\r\n\t * \t\t\t\t\tname: 'Unknown maps',\r\n\t * \t\t\t\t\tmaps: [\r\n\t * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\r\n\t * \t\t\t\t\t]\r\n\t * \t\t\t\t}\r\n\t * \t\t\t]\r\n\r\n\t*\t    };\r\n\t* @param {boolean} searchAll if true forces re-indexing of entire dat.\r\n\t*/\r\n  getMapListAsync: function(localReader, callback, searchAll) {\r\n    /// If seachAll flag is true, force a deep search\r\n    if (searchAll) {\r\n      localReader.readMapListAsync(true, callback);\r\n      return;\r\n    }\r\n\r\n    /// Check local storage for an existing map list\r\n    let mapList = localReader.loadMapList();\r\n\r\n    /// If there is no cached list, look for pre-defined maps.\r\n    if (!mapList) {\r\n      localReader.readMapListAsync(false, callback);\r\n    }\r\n\r\n    /// Otherwise, just fire the callback with the cached list\r\n    else {\r\n      callback(mapList);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Utility method used for rendering map files. Loads a map file and applies\r\n   * the provided renderers to it.\r\n   *\r\n   * @async\r\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\r\n   * @param  {Number}   \t\tfileName\tThe File Id of a mapc file.\r\n   * @param  {Array}   \t\trenderers\tAn array of renderer classes. Each\r\n   *                               \t\tclass should extend\r\n   *                               \t\t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\r\n   * @param  {Function}\t\tcallback    Callback function, takes the shared\r\n   *                                 \t\trenderer context as an argument.\r\n   * @param  {Class}\t\t\tlogger      A logger class of the same type as\r\n   *                               \t\t{{#crossLink \"Logger\"}}{{/crossLink}}\r\n   */\r\n  renderMapContentsAsync: function(\r\n    localReader,\r\n    fileName,\r\n    renderers,\r\n    callback,\r\n    logger\r\n  ) {\r\n    /// VO for storing result from renderers\r\n    let context = {};\r\n\r\n    let runAllRenderers;\r\n\r\n    /// Make sure we got an actuall ID number\r\n    if (parseInt(fileName)) {\r\n      /// File name is baseId, load using local reader.\r\n      localReader.loadFile(fileName, function(arrayBuffer) {\r\n        /// Set up datastream\r\n        let ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\r\n\r\n        /// Initiate Map file object. Connect callback\r\n        let mapFile = new T3D.GW2File(ds, 0);\r\n\r\n        /// Populate VO by running the renderers\r\n        runAllRenderers = function(i) {\r\n          /// Run each renderer\r\n          if (i < renderers.length) {\r\n            T3D.runRenderer(\r\n              renderers[i].renderClass,\r\n              localReader,\r\n              Object.assign(renderers[i].settings, { mapFile: mapFile }),\r\n              context,\r\n              runAllRenderers.bind(this, i + 1)\r\n            );\r\n          }\r\n\r\n          /// Fire callback with VO when done\r\n          else {\r\n            callback(context);\r\n          }\r\n        };\r\n\r\n        /// Starting point for running each renderer\r\n        runAllRenderers(0);\r\n      });\r\n    }\r\n\r\n    /// Primitive error message...\r\n    else {\r\n      let outputLogger = logger || T3D.Logger;\r\n      outputLogger.log(\r\n        T3D.Logger.TYPE_ERROR,\r\n        \"Map id must be an integer!, was:\",\r\n        fileName\r\n      );\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Utility method for applying a single renderer to a LocalReader insatnce.\r\n   *\r\n   * @async\r\n   *\r\n   * @param  {Class}\t\trenderClass\tA class extending\r\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\r\n   * @param  {LocalReader}localReader A fully initialized LocalReader instance\r\n   * @param  {Object}\t\tsettings    Settings passed to the renderer. Often\r\n   *                               \tspecifies thinks like what file ID should\r\n   *                               \tbe loaded.\r\n   * @param  {Object}\t\tcontext     The shared renderer context value object.\r\n   * @param  {Function} \tcb          Callback method passed to the renderAsync\r\n   *                                 \tmethod of the renderer.\r\n   */\r\n  runRenderer: function(renderClass, localReader, settings, context, cb) {\r\n    let r = new renderClass(localReader, settings, context);\r\n\r\n    r.renderAsync(cb);\r\n  },\r\n\r\n  /**\r\n   * @param  {Object} context      \tA shared renderer context value object.\r\n   * @param  {Class} \tclazz        \tA class extending\r\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}.\r\n   *                                \tSpecifies for renderer class you want to read\r\n   *                                \toutput.\r\n   * @param  {String} propName     \tThe name of the property written by the\r\n   *                                \trenderer that should retrtieved.\r\n   * @param  {any} \tdefaultValue \tThis value is passed back if no data could\r\n   *                              \tbe found.\r\n   * @return {any}    \t\t\t\tThe specified value from the conext if any,\r\n   *                          \t\totherwise defaultValue.\r\n   */\r\n  getContextValue: function(context, clazz, propName, defaultValue) {\r\n    let output = context[clazz.name];\r\n    if (output) {\r\n      return output[propName] ? output[propName] : defaultValue;\r\n    }\r\n    return defaultValue;\r\n  },\r\n\r\n  /**\r\n   * Check if the client web browser can render WebGL 3D content.\r\n   *\r\n   * @private\r\n   * @param  {boolean} return_context flag making this method return the canvas object instead of true\r\n   * @return {boolean} true if the client is WebGL enabled, false otherwise\r\n   */\r\n  hasWebGL: function(return_context) {\r\n    if (window.WebGLRenderingContext) {\r\n      let canvas = document.createElement(\"canvas\");\r\n      let names = [\"webgl\", \"experimental-webgl\", \"moz-webgl\", \"webkit-3d\"];\r\n      let context = false;\r\n\r\n      for (let i = 0; i < 4; i++) {\r\n        try {\r\n          context = canvas.getContext(names[i]);\r\n          if (context && typeof context.getParameter === \"function\") {\r\n            // WebGL is enabled\r\n            if (return_context) {\r\n              // return WebGL object if the function's argument is present\r\n              return { name: names[i], gl: context };\r\n            }\r\n            // else, return just true\r\n            return true;\r\n          }\r\n        } catch (e) {\r\n          //continue\r\n        }\r\n      }\r\n\r\n      // WebGL is supported, but disabled\r\n      return false;\r\n    }\r\n\r\n    // WebGL not supported\r\n    return false;\r\n  }\r\n};\r\n\r\n/* PRIVATE METHODS */\r\n\r\n/**\r\n * Performs checks for required browser capabilities and required third party libraries.\r\n * Loggs any warnings or error messages.\r\n *\r\n * @private\r\n * @return {Number} The ammount of errors and warnings generated.\r\n */\r\nfunction checkRequirements() {\r\n  let numErrors = 0;\r\n\r\n  if (!global.window || !window.indexedDB) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_ERROR,\r\n      \"T3D persistant storing and loading requires indexedDB support.\"\r\n    );\r\n    numErrors++;\r\n  }\r\n\r\n  if (typeof DataStream === \"undefined\") {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_ERROR,\r\n      \"T3D core functionality requires DataStream library.\"\r\n    );\r\n    numErrors++;\r\n  }\r\n\r\n  if (typeof THREE === \"undefined\") {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"T3D mesh generation requires three.js library.\"\r\n    );\r\n    numErrors++;\r\n  }\r\n\r\n  if (numErrors < 1) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_MESSAGE,\r\n      \"Tyria 3D API v\" + T3D.version + \" initialized.\"\r\n    );\r\n  }\r\n\r\n  return numErrors;\r\n}\r\n\r\n/**\r\n * Performs a quick and dirty check to find what chunk name definitions\r\n * appear multiple times in th formats array. Note that anything that\r\n * appears more than 2 times wil get a too hight value due to the\r\n * algorithm being... incorrect.\r\n *\r\n * @private\r\n * @return {Object} An object mapping duplicate chunk definition names.\r\n * to the number of apperances.\r\n */\r\n// eslint-disable-next-line no-unused-vars\r\nfunction findDuplicateChunkDefs() {\r\n  let dups = {};\r\n  T3D.formats.forEach(function(f1) {\r\n    T3D.formats.forEach(function(f2) {\r\n      if (f2.name === f1.name && f2 !== f1) {\r\n        if (dups[f1.name]) {\r\n          dups[f1.name]++;\r\n        } else {\r\n          dups[f1.name] = 1;\r\n        }\r\n      }\r\n    });\r\n  });\r\n  return dups;\r\n}\r\n\r\n/// Library checks requirements on startup\r\ncheckRequirements();\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst GW2File = require(\"../format/file/GW2File\");\r\n\r\n/**\r\n * Base class for data interpretors a.k.a. 'Renderers'\r\n *\r\n * Renderers are classes that collect and interpret data from the dat file.\r\n *\r\n * A {{#crossLink \"LocalReader\"}}{{/crossLink}} instance is used for accessing data from the dat.\r\n *\r\n * A {{#crossLink \"Logger\"}}{{/crossLink}} is used for posting progress output or error messages.\r\n *\r\n * Most Renderers use one or more\r\n * {{#crossLink \"GW2Chunk\"}}GW2Chunks{{/crossLink}}, typed data structures that can be read from\r\n * {{#crossLink \"GW2File\"}}GW2Files{{/crossLink}}.\r\n *\r\n * The generated data, be it strings, numbers or meshes are put into a value object structure called\r\n * the 'context'. The context can store data generated by multiple renderers and makes sure each\r\n * renderer type, or class has it's own value object within the context. This enables one renderer\r\n * to read data written by another renderer wihtout having to worry about overwriting existing data\r\n * within the context. Keep in mind that you will have to manually pass and clean the conext object!\r\n *\r\n * A clean context object should just be the empty javasript object : {}.\r\n *\r\n * When a Renderer is done it will fire the callback and any view interrested in retrieving the generated\r\n * data from the context can read it using\r\n * {{#crossLink \"T3D/getContextValue:method\"}}{{/crossLink}}.\r\n *\r\n *\r\n *\r\n *\r\n * @class DataRenderer\r\n * @constructor\r\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\r\n * @param  {Object} settings     Any settings used by this renderer.\r\n * @param  {Object} context      Shared value object between renderers.\r\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\r\n */\r\nlet DataRenderer = function(localReader, settings, context, logger) {\r\n  /// Just storing parameters\r\n  this.localReader = localReader;\r\n  this.settings = settings;\r\n  if (!settings) {\r\n    settings = {};\r\n  }\r\n  this.context = context;\r\n  this.context[this.constructor.name] = {};\r\n\r\n  if (logger) this.logger = logger;\r\n  else this.logger = T3D.Logger;\r\n};\r\n\r\n/**\r\n * Gets the output value object for a specified class within the context.\r\n *\r\n * @param  {Class} otherClass The class to fetch the output value object for.\r\n * If not specified the class of this instance will be used.\r\n * @return {Object}            The output value object for this class within the context.\r\n */\r\nDataRenderer.prototype.getOutput = function(otherClass) {\r\n  return this.context[otherClass ? otherClass.name : this.constructor.name];\r\n};\r\n\r\n/**\r\n * Basic rendering of unknown files. Output fileds generated:\r\n *\r\n * - *fileId* The fileId passed in the settings parameter when constructing this instance.\r\n *\r\n * - *rawData* An ArrayBuffer containg the infalted binary data of the loaded file.\r\n *\r\n * - *rawString* A string representation of the rawData\r\n *\r\n * - *image* A value object witht he fields 'width', 'height' and 'data' describing a RGBA bitmap\r\n * image. Only set if the loaded file was a texture.\r\n *\r\n * - *file* A GW2File representation of the loaded file. Only set if the loaded file was a Pack File.\r\n *\r\n * @async\r\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\r\n */\r\nDataRenderer.prototype.renderAsync = function(callback) {\r\n  let self = this;\r\n\r\n  this.localReader.loadFile(this.settings.id, function(inflatedData) {\r\n    /// Set fileId so callers can identify this VO\r\n    self.getOutput().fileId = self.settings.id;\r\n\r\n    /// Share inflated data\r\n    self.getOutput().rawData = inflatedData;\r\n\r\n    /// Construct raw string\r\n    let uarr = new Uint8Array(inflatedData);\r\n    let rawStrings = [];\r\n    let chunksize = 0xffff;\r\n    let len = Math.min(uarr.length, 10000);\r\n\r\n    // There is a maximum stack size. We cannot call String.fromCharCode with as many arguments as we want\r\n    for (let i = 0; i * chunksize < len; i++) {\r\n      rawStrings.push(\r\n        String.fromCharCode.apply(\r\n          null,\r\n          uarr.subarray(i * chunksize, (i + 1) * chunksize)\r\n        )\r\n      );\r\n    }\r\n\r\n    if (len < uarr.length) {\r\n      rawStrings.push(\r\n        \"T3D Ignored the last \" +\r\n          (uarr.length - len) +\r\n          \" bytes when generating this raw output\"\r\n      );\r\n    }\r\n\r\n    self.getOutput().rawString = rawStrings.join();\r\n\r\n    /// Check if this is an PF or ATEX file\r\n    // Binareis are MZ\r\n    let ds = new DataStream(inflatedData);\r\n    let first4 = ds.readCString(4);\r\n\r\n    /// Do special stuff for different fcc signatures\r\n    ///\r\n    /// fourcc != fcc::ATEX && fourcc != fcc::ATEC && fourcc != fcc::ATEP &&\r\n    /// fourcc != fcc::ATET && fourcc != fcc::ATEU && fourcc != fcc::ATTX)\r\n    ///\r\n    if (\r\n      first4 === \"ATEX\" ||\r\n      first4 === \"ATEC\" ||\r\n      first4 === \"ATEP\" ||\r\n      first4 === \"ATET\" ||\r\n      first4 === \"ATEU\" ||\r\n      first4 === \"ATTX\"\r\n    ) {\r\n      /// TODO: MOVE TO GW2 texture file!!\r\n      /// Load file using LocalReader.\r\n      self.localReader.loadTextureFile(self.settings.id, function(\r\n        inflatedData,\r\n        dxtType,\r\n        imageWidth,\r\n        imageHeigth\r\n      ) {\r\n        /// Create image using returned data.\r\n        let image = {\r\n          data: new Uint8Array(inflatedData),\r\n          width: imageWidth,\r\n          height: imageHeigth\r\n        };\r\n\r\n        self.getOutput().image = image;\r\n        callback();\r\n      });\r\n    } else if (first4.indexOf(\"PF\") === 0) {\r\n      self.getOutput().file = new GW2File(ds, 0);\r\n      callback();\r\n    } else {\r\n      self.getOutput().file = null;\r\n      callback();\r\n    }\r\n  });\r\n};\r\n\r\nmodule.exports = DataRenderer;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst RenderUtils = require(\"../util/RenderUtils\");\r\nconst DataRenderer = require(\"./DataRenderer\");\r\n\r\n/**\r\n *\r\n * A renderer that generates some of the environment objects of a map.\r\n *\r\n * @class EnvironmentRenderer\r\n * @constructor\r\n * @extends DataRenderer\r\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\r\n * @param  {Object} settings     Any settings used by this renderer.\r\n * *Must* specify \"mapFile\", a GW2File.\r\n * @param  {Object} context      Shared value object between renderers.\r\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\r\n */\r\nfunction EnvironmentRenderer(localReader, settings, context, logger) {\r\n  DataRenderer.call(this, localReader, settings, context, logger);\r\n\r\n  this.mapFile = this.settings.mapFile;\r\n\r\n  this.getMat = function(tex) {\r\n    return new THREE.MeshBasicMaterial({\r\n      map: tex,\r\n      side: THREE.BackSide,\r\n      fog: false,\r\n      depthWrite: false\r\n    });\r\n  };\r\n\r\n  this.loadTextureWithFallback = function(\r\n    targetMatIndices,\r\n    materialArray,\r\n    filename,\r\n    fallbackFilename,\r\n    hazeColorAsInt\r\n  ) {\r\n    let self = this;\r\n\r\n    function writeMat(mat) {\r\n      targetMatIndices.forEach(function(i) {\r\n        materialArray[i] = mat;\r\n      });\r\n    }\r\n\r\n    function loadFallback() {\r\n      let mat = self.getMat(new THREE.TextureLoader().load(fallbackFilename));\r\n\r\n      writeMat(mat);\r\n    }\r\n\r\n    function errorCallback() {\r\n      setTimeout(loadFallback, 1);\r\n    }\r\n\r\n    let mat = self.getMat(\r\n      RenderUtils.loadLocalTexture(\r\n        localReader,\r\n        filename,\r\n        null,\r\n        hazeColorAsInt,\r\n        errorCallback\r\n      )\r\n    );\r\n\r\n    writeMat(mat);\r\n  };\r\n\r\n  this.getHazeColor = function(environmentChunkData) {\r\n    let hazes = environmentChunkData && environmentChunkData.dataGlobal.haze;\r\n\r\n    if (!hazes || hazes.length <= 0) {\r\n      return [190, 160, 60];\r\n    } else {\r\n      return hazes[0].farColor;\r\n    }\r\n  };\r\n\r\n  this.parseLights = function(environmentChunkData) {\r\n    let self = this;\r\n\r\n    /// Set up output array\r\n    self.getOutput().lights = [];\r\n\r\n    let lights = environmentChunkData\r\n      ? environmentChunkData.dataGlobal.lighting\r\n      : [\r\n          {\r\n            lights: [],\r\n            backlightIntensity: 1.0,\r\n            backlightColor: [255, 255, 255]\r\n          }\r\n        ];\r\n\r\n    let ambientLight;\r\n\r\n    // var light = lights[0];\r\n    //\r\n    let hasLight = false;\r\n    lights.forEach(function(light /*, idx*/) {\r\n      if (hasLight) return;\r\n\r\n      /// Directional lights\r\n      // eslint-disable-next-line no-unused-vars\r\n      let sumDirLightIntensity = 0;\r\n\r\n      light.lights.forEach(function(dirLightData /*, idx*/) {\r\n        hasLight = true;\r\n\r\n        let color = new THREE.Color(\r\n          dirLightData.color[2] / 255.0,\r\n          dirLightData.color[1] / 255.0,\r\n          dirLightData.color[0] / 255.0\r\n        );\r\n\r\n        let directionalLight = new THREE.DirectionalLight(\r\n          color.getHex(),\r\n          dirLightData.intensity\r\n        );\r\n\r\n        directionalLight.position\r\n          .set(\r\n            -dirLightData.direction[0],\r\n            dirLightData.direction[2],\r\n            dirLightData.direction[1]\r\n          )\r\n          .normalize();\r\n\r\n        sumDirLightIntensity += dirLightData.intensity;\r\n\r\n        self.getOutput().lights.push(directionalLight);\r\n      }); // END for each directional light in light\r\n\r\n      /// Add some random directional lighting if there was no, in order to se SOME depth on models\r\n      if (!light.lights || light.lights.length === 0) {\r\n        let directions = [[0, 1, 0, 0.3], [1, 2, 1, 0.3], [-1, -2, -1, 0.3]];\r\n\r\n        directions.forEach(function(lightDir) {\r\n          let color = new THREE.Color(1, 1, 1);\r\n          let intensity = lightDir[3];\r\n          let directionalLight = new THREE.DirectionalLight(\r\n            color.getHex(),\r\n            intensity\r\n          );\r\n\r\n          directionalLight.position\r\n            .set(lightDir[0], lightDir[1], lightDir[2])\r\n            .normalize();\r\n\r\n          sumDirLightIntensity += intensity;\r\n\r\n          self.getOutput().lights.push(directionalLight);\r\n        });\r\n      }\r\n\r\n      /// Ambient light\r\n      // light.backlightIntensity /= sumDirLightIntensity +light.backlightIntensity;\r\n      // light.backlightIntensity = light.backlightIntensity;\r\n      let color = new THREE.Color(\r\n        (light.backlightIntensity * (255.0 - light.backlightColor[2])) / 255.0,\r\n        (light.backlightIntensity * (255.0 - light.backlightColor[1])) / 255.0,\r\n        (light.backlightIntensity * (255.0 - light.backlightColor[0])) / 255.0\r\n      );\r\n\r\n      ambientLight = new THREE.AmbientLight(color);\r\n    }); // END for each light in lighting\r\n\r\n    let ambientTotal = 0;\r\n    if (ambientLight) {\r\n      ambientTotal =\r\n        ambientLight.color.r + ambientLight.color.g + ambientLight.color.b;\r\n      this.getOutput().lights.push(ambientLight);\r\n    }\r\n\r\n    /// Parsing done, set hasLight flag and return\r\n    this.getOutput().hasLight = hasLight || ambientTotal > 0;\r\n  };\r\n\r\n  this.parseSkybox = function(\r\n    environmentChunkData,\r\n    parameterChunkData,\r\n    hazeColorAsInt\r\n  ) {\r\n    /// set up output array\r\n    this.getOutput().skyElements = [];\r\n\r\n    /// Grab sky texture.\r\n    /// index 0 and 1 day\r\n    /// index 2 and 3 evening\r\n    let skyModeTex =\r\n      this.environmentChunkData &&\r\n      this.environmentChunkData.dataGlobal.skyModeTex[0];\r\n\r\n    /// Fallback skyboxfrom dat.\r\n    if (!skyModeTex) {\r\n      skyModeTex = {\r\n        texPathNE: 1930687,\r\n        texPathSW: 193069,\r\n        texPathT: 193071\r\n      };\r\n    }\r\n\r\n    /// Calculate bounds\r\n    let bounds = parameterChunkData.rect;\r\n    let mapW = Math.abs(bounds.x1 - bounds.x2);\r\n    let mapD = Math.abs(bounds.y1 - bounds.y2);\r\n    // eslint-disable-next-line no-unused-vars\r\n    let boundSide = Math.max(mapW, mapD);\r\n\r\n    let materialArray = [];\r\n\r\n    /// Load skybox textures, fallback to hosted png files.\r\n    this.loadTextureWithFallback(\r\n      [1, 4],\r\n      materialArray,\r\n      skyModeTex.texPathNE + 1,\r\n      \"img/193068.png\",\r\n      hazeColorAsInt\r\n    );\r\n    this.loadTextureWithFallback(\r\n      [0, 5],\r\n      materialArray,\r\n      skyModeTex.texPathSW + 1,\r\n      \"img/193070.png\",\r\n      hazeColorAsInt\r\n    );\r\n    this.loadTextureWithFallback(\r\n      [2],\r\n      materialArray,\r\n      skyModeTex.texPathT + 1,\r\n      \"img/193072.png\",\r\n      hazeColorAsInt\r\n    );\r\n    materialArray[3] = new THREE.MeshBasicMaterial({ visible: false });\r\n\r\n    /// Create skybox geometry\r\n    let boxSize = 1024;\r\n    let skyGeometry = new THREE.BoxGeometry(boxSize, boxSize / 2, boxSize); // Width Height Depth\r\n\r\n    /// Ugly way of fixing UV maps for the skybox (I think)\r\n    skyGeometry.faceVertexUvs[0].forEach(function(vecs, idx) {\r\n      let face = Math.floor(idx / 2);\r\n\r\n      // PX NX\r\n      // PY NY\r\n      // PZ NZ\r\n\r\n      /// PX - WEST \tNX - EAST\r\n      if (face === 0 || face === 1) {\r\n        vecs.forEach(function(vec2) {\r\n          vec2.x = 1 - vec2.x;\r\n          vec2.y /= 2.0;\r\n          vec2.y += 0.5;\r\n        });\r\n      }\r\n\r\n      /// NZ - SOUTH \tPZ - NORTH\r\n      else if (face === 5 || face === 4) {\r\n        vecs.forEach(function(vec2) {\r\n          vec2.y /= -2.0;\r\n          vec2.y += 0.5;\r\n        });\r\n      } else {\r\n        vecs.forEach(function(vec2) {\r\n          vec2.x = 1 - vec2.x;\r\n        });\r\n      }\r\n    });\r\n\r\n    skyGeometry.uvsNeedUpdate = true;\r\n\r\n    /// Generate final skybox\r\n    let skyBox = new THREE.Mesh(skyGeometry, materialArray);\r\n\r\n    /// Put horizon in camera center\r\n    skyBox.translateY(boxSize / 4);\r\n    // skyBox.translateY( -environmentChunk.data.dataGlobal.sky.verticalOffset );\r\n\r\n    /// Write to output\r\n    this.getOutput().skyElements.push(skyBox);\r\n  };\r\n}\r\n\r\n/// DataRenderer inheritance:\r\nEnvironmentRenderer.prototype = Object.create(DataRenderer.prototype);\r\nEnvironmentRenderer.prototype.constructor = EnvironmentRenderer;\r\n\r\n/**\r\n * Output fileds generated:\r\n *\r\n * - *hazeColor* Array of RGBA values describing the global haze color of the map.\r\n * - *lights* An array of THREE.DirectionalLight and  THREE.AmbientLight objects.\r\n * - *hasLight* Boolean is false if no directional lights were added to \"lights\".\r\n * - *skyElements* A textured THREE.Mesh skybox.\r\n *\r\n * @async\r\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\r\n */\r\nEnvironmentRenderer.prototype.renderAsync = function(callback) {\r\n  let environmentChunkData = this.mapFile.getChunk(\"env\").data;\r\n  let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\r\n\r\n  /// Set renderer clear color from environment haze\r\n  let hazeColor = this.getHazeColor(environmentChunkData);\r\n  let hazeColorAsInt =\r\n    hazeColor[2] * 256 * 256 + hazeColor[1] * 256 + hazeColor[0];\r\n  this.getOutput().hazeColor = hazeColor;\r\n\r\n  /// Add directional lights to output. Also write hasLight flag\r\n  this.parseLights(environmentChunkData);\r\n\r\n  /// Generate skybox\r\n  this.parseSkybox(environmentChunkData, parameterChunkData, hazeColorAsInt);\r\n\r\n  /// All parsing is synchronous, just fire callback\r\n  callback();\r\n};\r\n\r\nmodule.exports = EnvironmentRenderer;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst DataRenderer = require(\"./DataRenderer\");\r\n\r\n/**\r\n *\r\n * A renderer that generates meshes describing the collisions of a map.\r\n *\r\n * @class HavokRenderer\r\n * @constructor\r\n * @extends DataRenderer\r\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\r\n * @param  {Object} settings     Any settings used by this renderer.\r\n * *Must* specify \"mapFile\", a GW2File. If \"visible\" is specified and true, the generated meshes will be textured\r\n * with a MeshNormalMaterial, otherwise they will not be visible.\r\n * @param  {Object} context      Shared value object between renderers.\r\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\r\n */\r\nfunction HavokRenderer(localReader, settings, context, logger) {\r\n  DataRenderer.call(this, localReader, settings, context, logger);\r\n\r\n  this.mapFile = this.settings.mapFile;\r\n\r\n  this.lastP = -1;\r\n  this.seed = 1;\r\n  this.meshes = [];\r\n\r\n  /**\r\n   * TODO\r\n   *\r\n   * @param  {Function} callback         [description]\r\n   * @async\r\n   */\r\n  this.renderModels = function(models, title, callback) {\r\n    let mat;\r\n    if (this.settings && this.settings.visible) {\r\n      mat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });\r\n    } else {\r\n      mat = new THREE.MeshBasicMaterial({ visible: false });\r\n    }\r\n\r\n    this.parseAllModels(models, mat, title, 200, 0, callback);\r\n  };\r\n\r\n  /**\r\n   * TODO\r\n   *\r\n   * @param  {*} animation  [description]\r\n   * @param  {*} collisions [description]\r\n   * @return {*}            [description]\r\n   */\r\n  this.getCollisionsForAnimation = function(animation, collisions) {\r\n    let ret = [];\r\n\r\n    for (let i = 0; i < animation.collisionIndices.length; i++) {\r\n      let index = animation.collisionIndices[i];\r\n      let collision = collisions[index];\r\n      collision.index = index;\r\n      ret.push(collision);\r\n    }\r\n\r\n    return ret;\r\n  };\r\n\r\n  /**\r\n   * TODO\r\n   *\r\n   * @param  {*} models       [description]\r\n   * @param  {*} mat       [description]\r\n   * @param  {*} title     [description]\r\n   * @param  {*} chunkSize [description]\r\n   * @param  {*} offset    [description]\r\n   * @return {*} callback          [description]\r\n   * @async\r\n   */\r\n  this.parseAllModels = function(\r\n    models,\r\n    mat,\r\n    title,\r\n    chunkSize,\r\n    offset,\r\n    callback\r\n  ) {\r\n    let i = offset;\r\n\r\n    for (; i < offset + chunkSize && i < models.length; i++) {\r\n      let p = Math.round((i * 100) / models.length);\r\n      if (p !== this.lastP) {\r\n        this.logger.log(\r\n          T3D.Logger.TYPE_PROGRESS,\r\n          \"Loading Collision Models (\" + title + \")\",\r\n          p\r\n        );\r\n        this.lastP = p;\r\n      }\r\n\r\n      /// Get animation object\r\n      let animation = this.animationFromGeomIndex(\r\n        models[i].geometryIndex,\r\n        this.geometries,\r\n        this.animations\r\n      );\r\n\r\n      let collisions = this.getCollisionsForAnimation(\r\n        animation,\r\n        this.havokChunkData.collisions\r\n      );\r\n\r\n      for (let j = 0; j < collisions.length; j++) {\r\n        let collision = collisions[j];\r\n        this.renderMesh(collision, models[i], mat);\r\n      }\r\n    }\r\n\r\n    if (i < models.length) {\r\n      window.setTimeout(\r\n        this.parseAllModels.bind(\r\n          this,\r\n          models,\r\n          mat,\r\n          title,\r\n          chunkSize,\r\n          offset + chunkSize,\r\n          callback\r\n        ),\r\n        10 /* time in ms to next call */\r\n      );\r\n    } else {\r\n      callback();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * TODO\r\n   *\r\n   * @param  {*} propGeomIndex [description]\r\n   * @param  {*} geometries    [description]\r\n   * @param  {*} animations    [description]\r\n   * @return {*}               [description]\r\n   */\r\n  this.animationFromGeomIndex = function(\r\n    propGeomIndex,\r\n    geometries,\r\n    animations\r\n  ) {\r\n    // geometries is just list of all geometries.animations[end] for now\r\n    let l = geometries[propGeomIndex].animations.length;\r\n\r\n    return animations[geometries[propGeomIndex].animations[l - 1]];\r\n    // return animations[ geometries[propGeomIndex].animations[0] ];\r\n  };\r\n\r\n  /**\r\n   * TODO\r\n   *\r\n   * @param  {*} collision [description]\r\n   * @param  {*} model     [description]\r\n   * @param  {*} mat       [description]\r\n   * @return {*}           [description]\r\n   */\r\n  this.renderMesh = function(collision, model, mat) {\r\n    let pos = model.translate;\r\n    let rot = model.rotate;\r\n    let scale = 32 * model.scale;\r\n\r\n    /// Generate mesh\r\n    let mesh = this.parseHavokMesh(collision, mat);\r\n\r\n    /// Position mesh\r\n    /// \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"\r\n    mesh.position.set(pos[0], -pos[2], -pos[1]);\r\n\r\n    /// Scale mesh\r\n    if (scale) mesh.scale.set(scale, scale, scale);\r\n\r\n    /// Rotate mesh\r\n    if (rot) {\r\n      mesh.rotation.order = \"ZXY\";\r\n\r\n      // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\r\n      mesh.rotation.set(rot[0], -rot[2], -rot[1]);\r\n    }\r\n\r\n    /// Add mesh to scene and collisions\r\n    this.getOutput().meshes.push(mesh);\r\n  };\r\n\r\n  /**\r\n   * TODO\r\n   *\r\n   * @return {*} [description]\r\n   */\r\n  this.seedRandom = function() {\r\n    let x = Math.sin(this.seed++) * 10000;\r\n    return x - Math.floor(x);\r\n  };\r\n\r\n  /**\r\n   * TODO\r\n   *\r\n   * @param  {*} collision [description]\r\n   * @param  {*} mat       [description]\r\n   * @return {*}           [description]\r\n   */\r\n  this.parseHavokMesh = function(collision, mat) {\r\n    let index = collision.index;\r\n\r\n    if (!this.meshes[index]) {\r\n      let geom = new THREE.Geometry();\r\n\r\n      /// Pass vertices\r\n      for (let i = 0; i < collision.vertices.length; i++) {\r\n        let v = collision.vertices[i];\r\n        // \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"]\r\n        geom.vertices.push(new THREE.Vector3(v[0], v[2], -v[1]));\r\n      }\r\n\r\n      /// Pass faces\r\n      for (let i = 0; i < collision.indices.length; i += 3) {\r\n        let f1 = collision.indices[i];\r\n        let f2 = collision.indices[i + 1];\r\n        let f3 = collision.indices[i + 2];\r\n\r\n        if (\r\n          f1 <= collision.vertices.length &&\r\n          f2 <= collision.vertices.length &&\r\n          f3 <= collision.vertices.length\r\n        ) {\r\n          geom.faces.push(new THREE.Face3(f1, f2, f3));\r\n        } else {\r\n          this.logger.log(\r\n            T3D.Logger.TYPE_ERROR,\r\n            \"Errorus index in havok model geometry.\"\r\n          );\r\n        }\r\n      }\r\n\r\n      /// Prepare geometry and pass new mesh\r\n      geom.computeFaceNormals();\r\n      // geom.computeVertexNormals();\r\n\r\n      this.meshes[index] = new THREE.Mesh(geom, mat);\r\n\r\n      return this.meshes[index];\r\n    } else {\r\n      return this.meshes[index].clone();\r\n    }\r\n  };\r\n}\r\n\r\n/// DataRenderer inheritance:\r\nHavokRenderer.prototype = Object.create(DataRenderer.prototype);\r\nHavokRenderer.prototype.constructor = HavokRenderer;\r\n\r\n/**\r\n * Output fileds generated:\r\n *\r\n * - *boundingBox* Array of values describing the bounding box of all collision.\r\n * - *meshes* An array of THREE.Mesh objects visualizing all collision in the map.\r\n *\r\n * @async\r\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\r\n */\r\nHavokRenderer.prototype.renderAsync = function(callback) {\r\n  let self = this;\r\n\r\n  // TODO:The design of this method pretty much requires one instance\r\n  // of the class per parallel async render. Should probably fix this\r\n  // at some point...\r\n\r\n  /// Get required chunks\r\n  this.havokChunkData = this.mapFile.getChunk(\"havk\").data;\r\n\r\n  /// Set static bounds to the bounds of the havk models\r\n  this.getOutput().boundingBox = this.havokChunkData.boundsMax;\r\n\r\n  /// Clear old meshes\r\n  this.meshes = [];\r\n\r\n  /// Set up output array\r\n  this.getOutput().meshes = [];\r\n\r\n  /// Grab model raw data from the chunk.\r\n  /// Add missing scale value to obs models.\r\n  let propModels = this.havokChunkData.propModels;\r\n  let zoneModels = this.havokChunkData.zoneModels;\r\n  let obsModels = this.havokChunkData.obsModels;\r\n  obsModels.forEach(function(mdl) {\r\n    mdl.scale = 1;\r\n  });\r\n\r\n  /// Store geoms and animations from the file in hte instance so we don't\r\n  /// have to pass them arround too much. (fix this later)\r\n  this.geometries = this.havokChunkData.geometries;\r\n  this.animations = this.havokChunkData.animations;\r\n\r\n  /// Render \"prop\", \"zone\" and \"obs\" models in that order.\r\n  let renderZoneModelsCB = function() {\r\n    self.renderModels(obsModels, \"obs\", callback);\r\n  };\r\n  let renderPropModelsCB = function() {\r\n    self.renderModels(zoneModels, \"zone\", renderZoneModelsCB);\r\n  };\r\n  self.renderModels(propModels, \"prop\", renderPropModelsCB);\r\n};\r\n\r\nmodule.exports = HavokRenderer;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst RenderUtils = require(\"../util/RenderUtils\");\r\nconst DataRenderer = require(\"./DataRenderer\");\r\n\r\n/**\r\n *\r\n * A renderer that generates property models for a map.\r\n *\r\n * @class PropertiesRenderer\r\n * @constructor\r\n * @extends DataRenderer\r\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\r\n * @param  {Object} settings     Any settings used by this renderer.\r\n * *Must* specify \"mapFile\", a GW2File.\r\n * @param  {Object} context      Shared value object between renderers.\r\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\r\n */\r\nfunction PropertiesRenderer(localReader, settings, context, logger) {\r\n  DataRenderer.call(this, localReader, settings, context, logger);\r\n  this.mapFile = this.settings.mapFile;\r\n}\r\n\r\n/// DataRenderer inheritance:\r\nPropertiesRenderer.prototype = Object.create(DataRenderer.prototype);\r\nPropertiesRenderer.prototype.constructor = PropertiesRenderer;\r\n\r\n/**\r\n * Renders all property meshes in a GW2 map described by the map's PROP chunk.\r\n * Output fileds generated:\r\n *\r\n * - *meshes* An array of THREE.Mesh objects visualizing all property models refered by this map.\r\n *\r\n * @async\r\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\r\n */\r\nPropertiesRenderer.prototype.renderAsync = function(callback) {\r\n  let self = this;\r\n\r\n  self.getOutput().meshes = [];\r\n\r\n  let propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\r\n\r\n  if (!propertiesChunkData) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  let props = propertiesChunkData.propArray;\r\n  let animProps = propertiesChunkData.propAnimArray;\r\n  let instanceProps = propertiesChunkData.propInstanceArray;\r\n  let metaProps = propertiesChunkData.propMetaArray;\r\n\r\n  /// Concat all prop types\r\n  props = props\r\n    .concat(animProps)\r\n    .concat(instanceProps)\r\n    .concat(metaProps);\r\n\r\n  /// Create mesh cache\r\n  self.meshCache = {};\r\n  self.textureCache = {};\r\n\r\n  // For now, we'll do all load in serial\r\n  // TODO: load unique meshes and textures in parallell (asynch), then render!\r\n  let lastPct = -1;\r\n\r\n  let renderIndex = function(idx) {\r\n    if (idx >= props.length) {\r\n      /// Empty mesh cache\r\n      self.meshCache = {};\r\n      self.textureCache = {};\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    let pct = Math.round((1000.0 * idx) / props.length);\r\n    pct /= 10.0;\r\n\r\n    /// Log progress\r\n    if (lastPct !== pct) {\r\n      let pctStr = pct + (pct.toString().indexOf(\".\") < 0 ? \".0\" : \"\");\r\n\r\n      self.logger.log(\r\n        T3D.Logger.TYPE_PROGRESS,\r\n        \"Loading 3D Models (Props)\",\r\n        pctStr\r\n      );\r\n      lastPct = pct;\r\n    }\r\n\r\n    /// Read prop at index.\r\n    let prop = props[idx];\r\n\r\n    /// Adds a single mesh to a group.\r\n    let addMeshToLOD = function(mesh, groups, lod, prop, needsClone) {\r\n      /// Read lod distance before overwriting mesh variable\r\n      let lodDist = prop.lod2 !== 0 ? prop.lod2 : mesh.lodOverride[1];\r\n\r\n      /// Read flags before overwriting mesh variable\r\n      let flags = mesh.flags;\r\n\r\n      /// Mesh flags are 0 1 4\r\n      /// For now, use flag 0 as the default level of detail\r\n      if (flags === 0) lodDist = 0;\r\n\r\n      /// Create new empty mesh if needed\r\n      if (needsClone) {\r\n        mesh = new THREE.Mesh(mesh.geometry, mesh.material);\r\n      }\r\n\r\n      mesh.updateMatrix();\r\n      mesh.matrixAutoUpdate = false;\r\n\r\n      // Find group for this LOD distance\r\n      if (groups[lodDist]) {\r\n        groups[lodDist].add(mesh);\r\n      }\r\n      // Or create LOD group and add to a level of detail\r\n      // WIP, needs some testing!\r\n      else {\r\n        let group = new THREE.Group();\r\n        group.updateMatrix();\r\n        group.matrixAutoUpdate = false;\r\n        group.add(mesh);\r\n        groups[lodDist] = group;\r\n        lod.addLevel(group, lodDist);\r\n      }\r\n\r\n      return lodDist;\r\n    };\r\n\r\n    /// Adds array of meshes to the scene, also adds transform clones\r\n    let addMeshesToScene = function(meshArray, needsClone, boundingSphere) {\r\n      /// Add original\r\n\r\n      /// Make LOD object and an array of groups for each LOD level\r\n      let groups = {};\r\n      let lod = new THREE.LOD();\r\n\r\n      /// Each mesh is added to a group corresponding to its LOD distane\r\n      let maxDist = 0;\r\n      meshArray.forEach(function(mesh) {\r\n        maxDist = Math.max(\r\n          maxDist,\r\n          addMeshToLOD(mesh, groups, lod, prop, needsClone)\r\n        );\r\n      });\r\n\r\n      /// Add invisible level (the raycaster crashes on lod without any levels)\r\n      lod.addLevel(new THREE.Group(), 100000);\r\n\r\n      /// Set position, scale and rotation of the LOD object\r\n      if (prop.rotation) {\r\n        lod.rotation.order = \"ZXY\";\r\n        // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\r\n        lod.rotation.set(\r\n          prop.rotation[0],\r\n          -prop.rotation[2],\r\n          -prop.rotation[1]\r\n        );\r\n      }\r\n      lod.scale.set(prop.scale, prop.scale, prop.scale);\r\n      lod.position.set(prop.position[0], -prop.position[2], -prop.position[1]);\r\n\r\n      lod.boundingSphereRadius =\r\n        (boundingSphere && boundingSphere.radius\r\n          ? boundingSphere.radius\r\n          : 1.0) * prop.scale;\r\n\r\n      lod.updateMatrix();\r\n      lod.matrixAutoUpdate = false;\r\n\r\n      /// Show highest level always\r\n      // lod.update(lod);\r\n\r\n      // Add LOD containing mesh instances to scene\r\n      self.getOutput().meshes.push(lod);\r\n\r\n      // Add one copy per transform, needs to be within it's own LOD\r\n      if (prop.transforms) {\r\n        prop.transforms.forEach(function(transform) {\r\n          /// Make LOD object and an array of groups for each LOD level\r\n          let groups = {};\r\n          let lod = new THREE.LOD();\r\n\r\n          /// Each mesh is added to a group corresponding to its LOD distane\r\n          let maxDist = 0;\r\n          meshArray.forEach(function(mesh) {\r\n            maxDist = Math.max(\r\n              maxDist,\r\n              addMeshToLOD(mesh, groups, lod, prop, true)\r\n            );\r\n          });\r\n\r\n          /// Add invisible level\r\n          // lod.addLevel(new THREE.Group(),10000);\r\n\r\n          /// Set position, scale and rotation of the LOD object\r\n          if (transform.rotation) {\r\n            lod.rotation.order = \"ZXY\";\r\n            lod.rotation.set(\r\n              transform.rotation[0],\r\n              -transform.rotation[2],\r\n              -transform.rotation[1]\r\n            );\r\n          }\r\n          lod.scale.set(transform.scale, transform.scale, transform.scale);\r\n          lod.position.set(\r\n            transform.position[0],\r\n            -transform.position[2],\r\n            -transform.position[1]\r\n          );\r\n\r\n          lod.updateMatrix();\r\n          lod.matrixAutoUpdate = false;\r\n\r\n          lod.boundingSphereRadius =\r\n            (boundingSphere && boundingSphere.radius\r\n              ? boundingSphere.radius\r\n              : 1.0) * prop.scale;\r\n\r\n          /// Show highest level always\r\n          lod.update(lod);\r\n\r\n          /// Add LOD containing mesh instances to scenerender: function(propertiesChunkHeader, map, localReader, renderCallback){\r\n          self.getOutput().meshes.push(lod);\r\n        });\r\n      }\r\n    };\r\n\r\n    /// Get meshes\r\n    let showUnmaterialed = false;\r\n    RenderUtils.getMeshesForFilename(\r\n      prop.filename,\r\n      prop.color,\r\n      self.localReader,\r\n      self.meshCache,\r\n      self.textureCache,\r\n      showUnmaterialed,\r\n      function(meshes, isCached, boundingSphere) {\r\n        if (meshes) {\r\n          addMeshesToScene(meshes, isCached, boundingSphere);\r\n        }\r\n\r\n        /// Render next prop\r\n        renderIndex(idx + 1);\r\n      }\r\n    );\r\n  };\r\n\r\n  /// Start serial loading and redering. (to allow re-using meshes and textures)\r\n  renderIndex(0);\r\n};\r\n\r\n/**\r\n * TODO: write description. Used for export feature\r\n * @param  {Function} callback [description]\r\n * @return {*}            [description]\r\n */\r\nPropertiesRenderer.prototype.getFileIdsAsync = function(callback) {\r\n  let fileIds = [];\r\n\r\n  let propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\r\n\r\n  let props = propertiesChunkData.propArray;\r\n  let animProps = propertiesChunkData.propAnimArray;\r\n  let instanceProps = propertiesChunkData.propInstanceArray;\r\n  let metaProps = propertiesChunkData.propMetaArray;\r\n\r\n  props = props\r\n    .concat(animProps)\r\n    .concat(instanceProps)\r\n    .concat(metaProps);\r\n\r\n  let getIdsForProp = function(idx) {\r\n    if (idx >= props.length) {\r\n      callback(fileIds);\r\n      return;\r\n    }\r\n\r\n    if (idx % 100 === 0) {\r\n      this.logger.log(\r\n        T3D.Logger.TYPE_MESSAGE,\r\n        \"getting ids for entry\",\r\n        idx,\r\n        \"of\",\r\n        props.length\r\n      );\r\n    }\r\n\r\n    let prop = props[idx];\r\n    RenderUtils.getFilesUsedByModel(\r\n      prop.filename,\r\n      {\r\n        /* broken, needs localReader */\r\n      },\r\n      function(propFileIds) {\r\n        fileIds = fileIds.concat(propFileIds);\r\n        getIdsForProp(idx + 1);\r\n      }\r\n    );\r\n  };\r\n\r\n  getIdsForProp(0);\r\n};\r\n\r\nmodule.exports = PropertiesRenderer;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst RenderUtils = require(\"../util/RenderUtils\");\r\nconst DataRenderer = require(\"./DataRenderer\");\r\n\r\n/**\r\n *\r\n * A renderer that generates meshes for a single model file.\r\n *\r\n * @class SingleModelRenderer\r\n * @constructor\r\n * @extends DataRenderer\r\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\r\n * @param  {Object} settings     Any settings used by this renderer.\r\n * *Must* specify \"id\" the base ID or file ID of the model to generate meshes for.\r\n * @param  {Object} context      Shared value object between renderers.\r\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\r\n */\r\nfunction SingleModelRenderer(localReader, settings, context, logger) {\r\n  DataRenderer.call(this, localReader, settings, context, logger);\r\n}\r\n\r\n/// DataRenderer inheritance:\r\nSingleModelRenderer.prototype = Object.create(DataRenderer.prototype);\r\nSingleModelRenderer.prototype.constructor = SingleModelRenderer;\r\n\r\n/**\r\n * Output fileds generated:\r\n *\r\n * - *meshes* An array of THREE.Mesh objects visualizing this model file.\r\n *\r\n * @async\r\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\r\n */\r\nSingleModelRenderer.prototype.renderAsync = function(callback) {\r\n  let self = this;\r\n\r\n  /// Get file id\r\n  let fileId = this.settings.id;\r\n  let showUnmaterialed = true;\r\n\r\n  /// Load the model file\r\n  let meshCache = {};\r\n  let textureCache = {};\r\n\r\n  /// Set up output array\r\n  self.getOutput().meshes = [];\r\n\r\n  RenderUtils.getMeshesForFilename(\r\n    fileId,\r\n    0x00ff00,\r\n    self.localReader,\r\n    meshCache,\r\n    textureCache,\r\n    showUnmaterialed,\r\n    function(meshes, isCached, boundingSphere) {\r\n      if (meshes) {\r\n        meshes.forEach(function(mesh) {\r\n          mesh.boundingSphere = boundingSphere;\r\n          self.getOutput().meshes.push(mesh);\r\n        });\r\n      }\r\n\r\n      /// Fire callback after all meshes have been added.\r\n      meshCache = {};\r\n      callback();\r\n    }\r\n  );\r\n};\r\n\r\nmodule.exports = SingleModelRenderer;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst DataRenderer = require(\"./DataRenderer\");\r\n\r\n/**\r\n *\r\n * A renderer that generates a list of readable strings from a \"strs\" file.\r\n *\r\n * @class StringRenderer\r\n * @constructor\r\n * @extends DataRenderer\r\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\r\n * @param  {Object} settings     Any settings used by this renderer.\r\n * *Must* specify \"id\" the base ID or file ID of the string file to read strings from.\r\n * @param  {Object} context      Shared value object between renderers.\r\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\r\n */\r\nfunction StringRenderer(localReader, settings, context, logger) {\r\n  DataRenderer.call(this, localReader, settings, context, logger);\r\n}\r\n\r\n/// DataRenderer inheritance:\r\nStringRenderer.prototype = Object.create(DataRenderer.prototype);\r\nStringRenderer.prototype.constructor = StringRenderer;\r\n\r\n/**\r\n * Output fileds generated:\r\n *\r\n * - *strings* An array of objects. Each object has a \"recid\"-property specifing on what index within the file\r\n * a given string was found, and a \"value\"-property specigying the string value.\r\n *\r\n * - *language* An integer specifing the language of the loaded file.\r\n *\r\n * @async\r\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\r\n */\r\nStringRenderer.prototype.renderAsync = function(callback) {\r\n  let self = this;\r\n\r\n  /// Get file id\r\n  // eslint-disable-next-line no-unused-vars\r\n  let fileId = this.settings.id;\r\n  // eslint-disable-next-line no-unused-vars\r\n  let showUnmaterialed = true;\r\n\r\n  /// Load the string file\r\n\r\n  /// Set up output array\r\n  this.getOutput().strings = [];\r\n\r\n  this.localReader.loadFile(this.settings.id, function(inflatedData) {\r\n    let ds = new DataStream(inflatedData);\r\n    let end = ds.byteLength - 2;\r\n\r\n    /// skip past fcc\r\n    ds.seek(4);\r\n\r\n    let entryHeaderDef = [\r\n      \"size\",\r\n      \"uint16\",\r\n      \"decryptionOffset\",\r\n      \"uint16\",\r\n      \"bitsPerSymbol\",\r\n      \"uint16\"\r\n    ];\r\n\r\n    let entryIndex = 0;\r\n\r\n    while (end - ds.position > 6) {\r\n      let entry = ds.readStruct(entryHeaderDef);\r\n      entry.size -= 6;\r\n\r\n      if (entry.size > 0) {\r\n        let isEncrypted =\r\n          entry.decryptionOffset !== 0 || entry.bitsPerSymbol !== 0x10;\r\n\r\n        /// UTF-16\r\n        if (!isEncrypted) {\r\n          let value = ds.readUCS2String(entry.size / 2);\r\n          self.getOutput().strings.push({\r\n            value: value,\r\n            recid: entryIndex\r\n          });\r\n        }\r\n\r\n        /// Other... ignored\r\n        else {\r\n          //continue\r\n        }\r\n      }\r\n\r\n      entryIndex++;\r\n    }\r\n\r\n    ds.seek(ds.byteLength - 2);\r\n    self.getOutput().language = ds.readUint16();\r\n    callback();\r\n  });\r\n};\r\n\r\nmodule.exports = StringRenderer;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst RenderUtils = require(\"../util/RenderUtils\");\r\nconst DataRenderer = require(\"./DataRenderer\");\r\nconst GW2File = require(\"../format/file/GW2File.js\");\r\n\r\nconst TerrainShader = require(\"../util/TerrainShader.js\");\r\n\r\n/**\r\n *\r\n * A renderer that generates the meshes for the terrain of a map.\r\n *\r\n *\r\n * Requires a context previously populated by a\r\n * {{#crossLink \"EnvironmentRenderer\"}}{{/crossLink}}.\r\n *\r\n * @class TerrainRenderer\r\n * @constructor\r\n * @extends DataRenderer\r\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\r\n * @param  {Object} settings     Any settings used by this renderer.\r\n * *Must* specify \"mapFile\", a GW2File.\r\n * @param  {Object} context      Shared value object between renderers.\r\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\r\n */\r\nfunction TerrainRenderer(localReader, mapFile, settings, context, logger) {\r\n  DataRenderer.call(this, localReader, mapFile, settings, context, logger);\r\n  this.mapFile = this.settings.mapFile;\r\n\r\n  this.drawWater = function(rect) {\r\n    /// Add Water\r\n    let material = new THREE.MeshBasicMaterial({\r\n        color: 0x5bb1e8,\r\n        wireframe: false,\r\n        opacity: 0.35\r\n      });\r\n\r\n    material.transparent = true;\r\n    return RenderUtils.renderRect(rect, 0, material);\r\n  };\r\n\r\n  this.parseNumChunks = function(terrainData) {\r\n    terrainData.numChunksD_1 = Math.sqrt(\r\n      (terrainData.dims[0] * terrainData.chunkArray.length) /\r\n        terrainData.dims[1]\r\n    );\r\n    terrainData.numChunksD_2 =\r\n      terrainData.chunkArray.length / terrainData.numChunksD_1;\r\n  };\r\n\r\n  this.loadPagedImageCallback = function(callback, infaltedBuffer) {\r\n    let self = this;\r\n\r\n    // Prep output array\r\n    self.getOutput().terrainTiles = [];\r\n\r\n    let pimgDS = new DataStream(infaltedBuffer);\r\n    let pimgFile = new GW2File(pimgDS, 0);\r\n    let pimgTableDataChunk = pimgFile.getChunk(\"pgtb\");\r\n    let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\r\n\r\n    this.mapRect = null;\r\n\r\n    /// Fetch chunks\r\n    let terrainData = this.mapFile.getChunk(\"trn\").data;\r\n    let parameterData = this.mapFile.getChunk(\"parm\").data;\r\n\r\n    /// Read settings\r\n    let maxAnisotropy = this.settings.anisotropy ? this.settings.anisotropy : 1;\r\n\r\n    //let chunks = [];\r\n    let chunkW = 35;\r\n\r\n    /// Calculate numChunksD_1 and _2\r\n    this.parseNumChunks(terrainData);\r\n\r\n    let xChunks = terrainData.numChunksD_1;\r\n    let yChunks = terrainData.numChunksD_2;\r\n\r\n    let allMaterials = terrainData.materials.materials;\r\n    let allTextures = terrainData.materials.texFileArray;\r\n\r\n    // Total map dx and dy\r\n    /*\r\n\t\told parameter data definition:\r\n\t\t\"x1\", \"float32\",\r\n\t\t\"y1\", \"float32\",\r\n\t\t\"x2\", \"float32\",\r\n\t\t\"y2\", \"float32\"\r\n\t\t*/\r\n    // var dx = parameterData.rect.x2 - parameterData.rect.x1;\r\n    // var dy = parameterData.rect.y2 - parameterData.rect.y1;\r\n    let dx = parameterData.rect[2] - parameterData.rect[0];\r\n    let dy = parameterData.rect[3] - parameterData.rect[1];\r\n\r\n    // Each chunk dx and dy\r\n    let cdx = (dx / terrainData.numChunksD_1) * 1; //  35/33;\r\n    let cdy = (dy / terrainData.numChunksD_2) * 1; // 35/33;\r\n    let n = 0;\r\n    let allMats = [];\r\n    let customMaterial = new THREE.MeshLambertMaterial({\r\n      side: THREE.DoubleSide,\r\n      color: 0x666666,\r\n      flatShading: true\r\n    });\r\n    //let texMats = {};\r\n\r\n    /// Load textures from PIMG and inject as material maps (textures)\r\n    let chunkTextures = {};\r\n\r\n    /// Load textures\r\n    if (pimgData) {\r\n      let strippedPages = pimgData.strippedPages;\r\n\r\n      /// Only use layer 0\r\n      strippedPages.forEach(function(page) {\r\n        /// Only load layer 0 and 1\r\n        if (page.layer <= 1) {\r\n          let filename = page.filename;\r\n          //let color = page.solidColor;\r\n          let coord = page.coord;\r\n\r\n          let matName = coord[0] + \",\" + coord[1];\r\n          if (page.layer === 1) matName += \"-2\";\r\n\r\n          /// Add texture to list, note that coord name is used, not actual file name\r\n          if (!chunkTextures[matName]) {\r\n            /// Load local texture, here we use file name!\r\n            let chunkTex = RenderUtils.loadLocalTexture(\r\n              self.localReader,\r\n              filename\r\n            );\r\n\r\n            if (chunkTex) {\r\n              /// Set repeat, antistropy and repeat Y\r\n              chunkTex.anisotropy = maxAnisotropy;\r\n              chunkTex.wrapS = THREE.RepeatWrapping;\r\n              chunkTex.wrapT = THREE.RepeatWrapping;\r\n            }\r\n\r\n            /// ...But store in coord name\r\n            chunkTextures[matName] = chunkTex;\r\n          }\r\n        }\r\n      }); /// end for each stripped page in pimgData\r\n    }\r\n\r\n    /// Render Each chunk\r\n    /// We'll make this async in order for the screen to be able to update\r\n\r\n    let renderChunk = function(cx, cy) {\r\n      let chunkIndex = cy * xChunks + cx;\r\n\r\n      let pageX = Math.floor(cx / 4);\r\n      let pageY = Math.floor(cy / 4);\r\n\r\n      // TODO: Terrain texture LOD ?\r\n      let chunkTextureIndices =\r\n        allMaterials[chunkIndex].loResMaterial.texIndexArray;\r\n      // let matFileName = allMaterials[chunkIndex].loResMaterial.materialFile;\r\n      // let chunkTextureIndices = allMaterials[chunkIndex].hiResMaterial.texIndexArray;\r\n      // let matFileName = allMaterials[chunkIndex].hiResMaterial.materialFile;\r\n      // let chunkData = terrainData.chunkArray[chunkIndex];\r\n      // let mainTex = allTextures[chunkTextureIndices[0]];\r\n      let mat = customMaterial;\r\n\r\n      /// TODO: just tick invert y = false...?\r\n      let pageOffetX = (cx % 4) / 4.0;\r\n      let pageOffetY = 0.75 - (cy % 4) / 4.0;\r\n\r\n      // offset 0 -> 0.75\r\n\r\n      // Make sure we have shared textures\r\n\r\n      /// Load and store all tiled textures\r\n      let fileNames = [];\r\n      for (let gi = 0; gi < chunkTextureIndices.length / 2; gi++) {\r\n        let textureFileName = allTextures[chunkTextureIndices[gi]].filename;\r\n\r\n        fileNames.push(textureFileName);\r\n\r\n        /// If the texture is not already loaded, read it from the .dat!\r\n        if (!chunkTextures[textureFileName]) {\r\n          /// Load local texture\r\n          let chunkTex = RenderUtils.loadLocalTexture(\r\n            self.localReader,\r\n            textureFileName\r\n          );\r\n\r\n          if (chunkTex) {\r\n            /// Set repeat, antistropy and repeat Y\r\n            chunkTex.anisotropy = maxAnisotropy;\r\n            chunkTex.wrapS = THREE.RepeatWrapping;\r\n            chunkTex.wrapT = THREE.RepeatWrapping;\r\n          }\r\n\r\n          chunkTextures[textureFileName] = chunkTex;\r\n        }\r\n      } /// End for each chunkTextureIndices\r\n\r\n      /// Create Composite texture material, refering the shared textures\r\n      let pageTexName = pageX + \",\" + pageY;\r\n      let pageTexName2 = pageX + \",\" + pageY + \"-2\";\r\n\r\n      /// TODO USe mapData (Chunk: env -> haze)\r\n      // var fog = SceneUtils.getScene().fog;\r\n      let fog = {\r\n        color: { r: 1, g: 1, b: 1 },\r\n        near: 0,\r\n        far: 0\r\n      };\r\n\r\n      /// Get haze color from environment rednerer\r\n      let envOutput = self.getOutput(T3D.EnvironmentRenderer);\r\n      if (envOutput.hazeColor) {\r\n        fog.color.r = envOutput.hazeColor[2] / 255.0;\r\n        fog.color.g = envOutput.hazeColor[1] / 255.0;\r\n        fog.color.b = envOutput.hazeColor[0] / 255.0;\r\n      }\r\n\r\n      let uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib[\"lights\"]]);\r\n\r\n      /// TODO: READ FROM VO, don't default to hard coded scale\r\n      uniforms.uvScale = { type: \"v2\", value: new THREE.Vector2(8.0, 8.0) };\r\n      uniforms.offset = {\r\n        type: \"v2\",\r\n        value: new THREE.Vector2(pageOffetX, pageOffetY)\r\n      };\r\n\r\n      uniforms.texturePicker = { type: \"t\", value: chunkTextures[pageTexName] };\r\n      uniforms.texturePicker2 = {\r\n        type: \"t\",\r\n        value: chunkTextures[pageTexName2]\r\n      };\r\n\r\n      uniforms.texture1 = { type: \"t\", value: chunkTextures[fileNames[0]] };\r\n      uniforms.texture2 = { type: \"t\", value: chunkTextures[fileNames[1]] };\r\n      uniforms.texture3 = { type: \"t\", value: chunkTextures[fileNames[2]] };\r\n      uniforms.texture4 = { type: \"t\", value: chunkTextures[fileNames[3]] };\r\n\r\n      mat = new THREE.ShaderMaterial({\r\n        uniforms: uniforms,\r\n        fragmentShader: TerrainShader.getFragmentShader(),\r\n        vertexShader: TerrainShader.getVertexShader()\r\n      });\r\n\r\n      /// Store referenceto each material\r\n      allMats.push(mat);\r\n\r\n      /// -1 for faces -> vertices , -2 for ignoring outer faces\r\n      let chunkGeo = new THREE.PlaneBufferGeometry(\r\n        cdx,\r\n        cdy,\r\n        chunkW - 3,\r\n        chunkW - 3\r\n      );\r\n\r\n      let cn = 0;\r\n\r\n      /// Render chunk\r\n\r\n      /// Each chunk vertex\r\n      for (let y = 0; y < chunkW; y++) {\r\n        for (let x = 0; x < chunkW; x++) {\r\n          if (x !== 0 && x !== chunkW - 1 && y !== 0 && y !== chunkW - 1) {\r\n            chunkGeo.getAttribute(\"position\").array[cn * 3 + 2] =\r\n              terrainData.heightMapArray[n];\r\n            cn++;\r\n          }\r\n\r\n          n++;\r\n        }\r\n      } // End each chunk vertex\r\n\r\n      /// Flip the plane to fit wonky THREE js world axes\r\n      let mS = new THREE.Matrix4().identity();\r\n      mS.elements[5] = -1;\r\n      chunkGeo.applyMatrix(mS);\r\n\r\n      /// Compute face normals for lighting, not used when textured\r\n      chunkGeo.computeFaceNormals();\r\n      // chunkGeo.computeVertexNormals();\r\n\r\n      /// Build chunk mesh!\r\n      let chunk;\r\n      chunk = new THREE.Mesh(chunkGeo, customMaterial);\r\n      if (mat.length) {\r\n        chunk = THREE.SceneUtils.createMultiMaterialObject(chunkGeo, mat);\r\n      } else {\r\n        chunk = new THREE.Mesh(chunkGeo, mat);\r\n      }\r\n\r\n      /// Move and rotate Mesh to fit in place\r\n      chunk.rotation.set(Math.PI / 2, 0, 0);\r\n\r\n      /// Last term is the new one: -cdx*(2/35)\r\n      let globalOffsetX = parameterData.rect[0] + cdx / 2;\r\n      let chunkOffsetX = cx * cdx;\r\n\r\n      chunk.position.x = globalOffsetX + chunkOffsetX;\r\n\r\n      /// Adjust for odd / even number of chunks\r\n      if (terrainData.numChunksD_2 % 2 === 0) {\r\n        /// Last term is the new one: -cdx*(2/35)\r\n        let globalOffsetY = parameterData.rect[1] + cdy / 2 - 0; // -cdy*(1/35);\r\n        let chunkOffsetY = cy * cdy * 1; // 33/35;\r\n\r\n        chunk.position.z = chunkOffsetY + globalOffsetY;\r\n      } else {\r\n        let globalOffsetY = parameterData.rect[1] - cdy / 2 + 0; // cdy*(1/35);\r\n        let chunkOffsetY = cy * cdy * 1; // 33/35;\r\n\r\n        chunk.position.z = globalOffsetY + chunkOffsetY;\r\n      }\r\n\r\n      let px = chunk.position.x;\r\n      let py = chunk.position.z;\r\n\r\n      if (!self.mapRect) {\r\n        self.mapRect = {\r\n          x1: px - cdx / 2,\r\n          x2: px + cdx / 2,\r\n          y1: py - cdy / 2,\r\n          y2: py + cdy / 2\r\n        };\r\n      }\r\n\r\n      self.mapRect.x1 = Math.min(self.mapRect.x1, px - cdx / 2);\r\n      self.mapRect.x2 = Math.max(self.mapRect.x2, px + cdx / 2);\r\n\r\n      self.mapRect.y1 = Math.min(self.mapRect.y1, py - cdy / 2);\r\n      self.mapRect.y2 = Math.max(self.mapRect.y2, py + cdy / 2);\r\n\r\n      chunk.updateMatrix();\r\n      chunk.updateMatrixWorld();\r\n\r\n      /// Add to list of stuff to render\r\n      /// TODO: Perhaps use some kind of props for each entry instead?\r\n      self.getOutput().terrainTiles.push(chunk);\r\n    }; /// End render chunk function\r\n\r\n    let stepChunk = function(cx, cy) {\r\n      if (cx >= xChunks) {\r\n        cx = 0;\r\n        cy++;\r\n      }\r\n\r\n      if (cy >= yChunks) {\r\n        /// Draw water surface using map bounds\r\n        self.getOutput().water = self.drawWater(self.mapRect);\r\n\r\n        /// Set bounds in output VO\r\n        self.getOutput().bounds = self.mapRect;\r\n\r\n        /// Fire call back, we're done rendering.\r\n        callback();\r\n        return;\r\n      }\r\n\r\n      let pct = Math.floor((100 * (cy * xChunks + cx)) / (xChunks * yChunks));\r\n\r\n      self.logger.log(T3D.Logger.TYPE_PROGRESS, \"Loading Terrain\", pct);\r\n\r\n      renderChunk(cx, cy);\r\n      setTimeout(stepChunk, 1, cx + 1, cy);\r\n    };\r\n\r\n    stepChunk(0, 0);\r\n  };\r\n}\r\n\r\n/// DataRenderer inheritance:\r\nTerrainRenderer.prototype = Object.create(DataRenderer.prototype);\r\nTerrainRenderer.prototype.constructor = TerrainRenderer;\r\n\r\n/**\r\n * Output fileds generated:\r\n *\r\n * - *terrainTiles* An array of THREE.Mesh objects visualizing terrain of the map.\r\n *\r\n * - *water* A THREE.Mesh object visualizing the bounds of the map.\r\n *\r\n * - *bounds* An object wiht x1, x2, y1, and y2 properties specifying the bounds of the map.\r\n *\r\n * @async\r\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\r\n */\r\nTerrainRenderer.prototype.renderAsync = function(callback) {\r\n  /// Load all paged Images, requires inflation of other pack files!\r\n  let pagedImageId = this.mapFile.getChunk(\"trn\").data.materials.pagedImage;\r\n  this.localReader.loadFile(\r\n    pagedImageId,\r\n    this.loadPagedImageCallback.bind(this, callback)\r\n  );\r\n};\r\n\r\n/**\r\n * TODO: write description. Used for export feature\r\n *\r\n * @param  {Function} callback [description]\r\n * @return {*}            [description]\r\n */\r\nTerrainRenderer.prototype.getFileIdsAsync = function(/* callback */) {\r\n  let terrainChunk = this.mapFile.getChunk(\"trn\");\r\n  let pimgTableDataChunk = this.mapFile.getChunk(\"pimg\");\r\n  let fileIds = [];\r\n\r\n  /// ------------ SPLASH TEXTURES ------------\r\n  let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\r\n  let strippedPages = pimgData.strippedPages;\r\n\r\n  /// Only use layer 0\r\n  strippedPages.forEach(function(page) {\r\n    /// Only load layer 0 and 1\r\n    if (page.layer <= 1 && page.filename > 0) {\r\n      fileIds.push(page.filename);\r\n    }\r\n  });\r\n  /// ------------ END SPLASH TEXTURES ------------\r\n\r\n  /// ------------ TILED IMAGES ------------\r\n  let terrainData = terrainChunk.data;\r\n  let allTextures = terrainData.materials.texFileArray;\r\n  allTextures.forEach(function(texture) {\r\n    if (texture.filename > 0) fileIds.push(texture.filename);\r\n  });\r\n  /// ------------ END TILED IMAGES ------------\r\n\r\n  return fileIds;\r\n};\r\n\r\nmodule.exports = TerrainRenderer;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst RenderUtils = require(\"../util/RenderUtils\");\r\nconst DataRenderer = require(\"./DataRenderer\");\r\n\r\n/**\r\n *\r\n * A renderer that generates zone models for a map.\r\n *\r\n * @class ZoneRenderer\r\n * @constructor\r\n * @extends DataRenderer\r\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\r\n * @param  {Object} settings     Any settings used by this renderer.\r\n * *Must* specify \"mapFile\", a GW2File.\r\n * @param  {Object} context      Shared value object between renderers.\r\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\r\n */\r\nfunction ZoneRenderer(localReader, settings, context, logger) {\r\n  DataRenderer.call(this, localReader, settings, context, logger);\r\n  this.mapFile = this.settings.mapFile;\r\n\r\n  /**\r\n   * TODO\r\n   *\r\n   * @param  {*} zone               [description]\r\n   * @param  {*} zoneDefs           [description]\r\n   * @param  {*} mapRect            [description]\r\n   * @param  {*} renderZoneCallback [description]\r\n   * @return {*}                    [description]\r\n   */\r\n  this.renderZone = function(zone, zoneDefs, mapRect, renderZoneCallback) {\r\n    let self = this;\r\n\r\n    /// Get Zone Definition\r\n    let zoneDef = null;\r\n    zoneDefs.forEach(function(zd) {\r\n      if (!zoneDef && zd.token === zone.defToken) zoneDef = zd;\r\n    });\r\n\r\n    /// Create array of all models to add:\r\n    // let models = []\r\n    let modelGroups = this.getModelGroups(zone, zoneDef, mapRect);\r\n\r\n    /// Create empty mesh cache\r\n    self.meshCache = {};\r\n    self.textureCache = {};\r\n\r\n    /*\r\n     * ---Keeping this out of the doc for now---\r\n     * Steps trough each model and renders it to the scene, allowing for efficient caching.\r\n     * @param  {Number} i - Current index within the models array\r\n     */\r\n    // var lastPct = -1;\r\n    let groupKeys = Object.keys(modelGroups);\r\n    function stepModels(i) {\r\n      /* var pct = Math.round(100.0*i / groupKeys.length);\r\n\t\t\tif(lastPct!=pct){\r\n\t\t\t\tconsole.log(\"Rendering ZONE models \"+pct);\r\n\t\t\t\tlastPct = pct;\r\n\t\t\t} */\r\n\r\n      if (i >= groupKeys.length) {\r\n        /// Empty mesh cache\r\n        self.meshCache = {};\r\n        self.textureCache = {};\r\n\r\n        /// Tell caller this zone is done loading\r\n        renderZoneCallback();\r\n        return;\r\n      }\r\n\r\n      /// Read model at index\r\n      /// var model = models[i];\r\n      let key = groupKeys[i]; /// key is model filename\r\n      let group = modelGroups[key];\r\n\r\n      let meshGroups = [];\r\n\r\n      /// Get model just once for this group\r\n      let showUnmaterialed = false;\r\n      RenderUtils.getMeshesForFilename(\r\n        key,\r\n        null,\r\n        self.localReader,\r\n        self.meshCache,\r\n        self.textureCache,\r\n        showUnmaterialed,\r\n\r\n        function(meshes /*, isCached*/) {\r\n          /// If there were meshes, add them to the scene with correct scaling rotation etc.\r\n          if (meshes /* && meshes.length == 3 */) {\r\n            /// Add one copy per model instance\r\n            /// TODO: add rotation!\r\n            /// TODO: fine tune position?\r\n            /// TODO: POTIMIZE!\r\n\r\n            group.forEach(function(model, instanceIdx) {\r\n              //let isCached = true;\r\n              //let scale = 1.0;\r\n\r\n              /// For each Mesh in the model\r\n              meshes.forEach(function(mesh, meshIdx) {\r\n                if (\r\n                  mesh.materialFlags ===\r\n                  525 /* || mesh.materialFlags == 520 || mesh.materialFlags == 521 */\r\n                ) {\r\n                  // console.log(\"Skipping lod\");\r\n                  return;\r\n                }\r\n\r\n                let move = { x: 0, y: 0, z: 0 };\r\n\r\n                /// Add to big mesh\r\n                if (!meshGroups[meshIdx]) {\r\n                  let mg = mesh.geometry.clone();\r\n                  meshGroups[meshIdx] = {\r\n                    readVerts: mg.getAttribute(\"position\").array,\r\n                    verts: new Float32Array(\r\n                      group.length * mg.getAttribute(\"position\").array.length\r\n                    ),\r\n\r\n                    readIndices: mg.getIndex().array,\r\n                    indices: new Uint32Array(\r\n                      group.length * mg.getIndex().array.length\r\n                    ),\r\n\r\n                    readUVs: mg.getAttribute(\"uv\").array,\r\n                    uvs: new Float32Array(\r\n                      group.length * mg.getAttribute(\"uv\").array.length\r\n                    ),\r\n\r\n                    readNormals: mg.getAttribute(\"normal\").array,\r\n                    normals: new Float32Array(\r\n                      group.length * mg.getAttribute(\"normal\").array.length\r\n                    ),\r\n\r\n                    material: mesh.material,\r\n                    // material:new THREE.MeshBasicMaterial( {color: 0xffcccc, wireframe:true} ),\r\n                    /* material : new THREE.PointCloudMaterial ({\r\n\t\t\t\t\t\t\t\t\t      color: 0xFF0000,\r\n\t\t\t\t\t\t\t\t\t      size: 20\r\n\t\t\t\t\t\t\t\t\t    }), */\r\n                    position: { x: model.x, y: model.y, z: model.z }\r\n                  };\r\n                } else {\r\n                  /// Translate\r\n                  move.x = model.x - meshGroups[meshIdx].position.x;\r\n                  move.y = model.z - meshGroups[meshIdx].position.z;\r\n                  move.z = model.y - meshGroups[meshIdx].position.y;\r\n                }\r\n\r\n                /// Add geom verts\r\n                let readVerts = meshGroups[meshIdx].readVerts;\r\n                let writeVerts = meshGroups[meshIdx].verts;\r\n                let stride = readVerts.length;\r\n\r\n                for (\r\n                  let i = 0, j = instanceIdx * stride;\r\n                  i < stride;\r\n                  i += 3, j += 3\r\n                ) {\r\n                  writeVerts[j + 0] = readVerts[i + 0] + move.x;\r\n                  writeVerts[j + 1] = readVerts[i + 1] + move.y;\r\n                  writeVerts[j + 2] = readVerts[i + 2] + move.z;\r\n                }\r\n\r\n                let readIndices = meshGroups[meshIdx].readIndices;\r\n                let writeIndices = meshGroups[meshIdx].indices;\r\n                let strideIndices = readIndices.length;\r\n                let shift = (stride * instanceIdx) / 3;\r\n\r\n                for (\r\n                  let i = 0, j = instanceIdx * strideIndices;\r\n                  i < strideIndices;\r\n                  i++, j++\r\n                ) {\r\n                  writeIndices[j] = readIndices[i] + shift;\r\n                }\r\n\r\n                let readUVs = meshGroups[meshIdx].readUVs;\r\n                let writeUvs = meshGroups[meshIdx].uvs;\r\n                let uvStride = readUVs.length;\r\n                for (\r\n                  let i = 0, j = instanceIdx * uvStride;\r\n                  i < uvStride;\r\n                  i++, j++\r\n                ) {\r\n                  writeUvs[j] = readUVs[i];\r\n                }\r\n\r\n                let readNormals = meshGroups[meshIdx].readNormals;\r\n                let writeNormals = meshGroups[meshIdx].normals;\r\n                let normalStride = readNormals.length;\r\n                for (\r\n                  let i = 0, j = instanceIdx * normalStride;\r\n                  i < normalStride;\r\n                  i++, j++\r\n                ) {\r\n                  writeNormals[j] = readNormals[i];\r\n                }\r\n              });\r\n            }); // End for each model in group\r\n          } /// End if meshes\r\n\r\n          /// Add each cluster of merged meshes to scene\r\n          meshGroups.forEach(function(meshGroup) {\r\n            let mergedGeom = new THREE.BufferGeometry();\r\n\r\n            mergedGeom.addAttribute(\r\n              \"position\",\r\n              new THREE.BufferAttribute(meshGroup.verts, 3)\r\n            );\r\n            // mergedGeom.addAttribute( 'index', new THREE.BufferAttribute( meshGroup.indices, 1) );\r\n            mergedGeom.setIndex(\r\n              new THREE.BufferAttribute(meshGroup.indices, 1)\r\n            );\r\n            mergedGeom.addAttribute(\r\n              \"normal\",\r\n              new THREE.BufferAttribute(meshGroup.normals, 3)\r\n            );\r\n            mergedGeom.addAttribute(\r\n              \"uv\",\r\n              new THREE.BufferAttribute(meshGroup.uvs, 2)\r\n            );\r\n\r\n            mergedGeom.buffersNeedUpdate = true;\r\n\r\n            let mesh = new THREE.Mesh(mergedGeom, meshGroup.material);\r\n            mesh.position.set(\r\n              meshGroup.position.x,\r\n              meshGroup.position.z,\r\n              meshGroup.position.y\r\n            );\r\n\r\n            self.getOutput().meshes.push(mesh);\r\n          }); // End for each meshgroup\r\n\r\n          /// Rendering is done, render next.\r\n          stepModels(i + 1);\r\n        }\r\n      );\r\n    } /// End function stepModels\r\n\r\n    /// Begin stepping trough the models, rendering them.\r\n    stepModels(0);\r\n  };\r\n\r\n  /**\r\n   * TODO\r\n   *\r\n   * @param  {*} zone    [description]\r\n   * @param  {*} zoneDef [description]\r\n   * @param  {*} mapRect [description]\r\n   * @return {*}         [description]\r\n   */\r\n  this.getModelGroups = function(zone, zoneDef, mapRect) {\r\n    /// Calculate rect in global coordinates\r\n    // let zPos = zone.zPos;\r\n\r\n    let mapX = mapRect[0];\r\n    let mapY = mapRect[1];\r\n    let c = 32 + 16;\r\n\r\n    // [\"x1\",\"uint32\",\"y1\",\"uint32\",\"x2\",\"uint32\", \"y2\", \"uint32\"]\r\n    let zoneRect = {\r\n      x1: zone.vertRect[0] * c + mapX,\r\n      x2: zone.vertRect[2] * c + mapX,\r\n      y1: zone.vertRect[1] * -c - mapY,\r\n      y2: zone.vertRect[3] * -c - mapY\r\n    };\r\n\r\n    /// Zone width and depth in local corrdinates\r\n    /* var zdx = zone.vertRect.x1-zone.vertRect.x2;\r\n\t\tvar zdy = zone.vertRect.y1-zone.vertRect.y2; */\r\n\r\n    /// These zones seems to overflow :/\r\n    if (zone.encodeData.length === 0) {\r\n      return {};\r\n    }\r\n\r\n    // console.log(\"Get mdl groups\", zone);\r\n    /// Testing: Render Zone Vert Rect\r\n    // RenderUtils.renderRect(zoneRect, -zPos);\r\n\r\n    let zdx = zone.vertRect[0] - zone.vertRect[2];\r\n    // let zdy = zone.vertRect[1] - zone.vertRect[3];\r\n\r\n    /// Zone Flags increases a linear position, used to step trough the Zone.\r\n    let linearPos = 0;\r\n\r\n    let modelGroups = {};\r\n\r\n    let terrainTiles = this.getOutput(T3D.TerrainRenderer).terrainTiles;\r\n\r\n    for (let i = 0; i < zone.flags.length; i += 2) {\r\n      /// Step forward\r\n      linearPos += zone.flags[i];\r\n\r\n      /// Check if a model should be placed\r\n      let flag = zone.flags[i + 1];\r\n      if (flag !== 0) {\r\n        /// Extract flag data\r\n        /// Layer is written in the last 4 bytes\r\n        let zoneDefLayer = flag >> 4;\r\n\r\n        /// Get Zone Definition Layer\r\n        let layer = zoneDef.layerDefArray[zoneDefLayer - 1];\r\n\r\n        /// TESTING Only show layers with height >= 3\r\n        if (layer /* && layer.height >= 0 */) {\r\n          /// Get X and Y from linear position\r\n          let modelX = (linearPos % zdx) * c + zoneRect.x1;\r\n          let modelY = Math.floor(linearPos / zdx) * c + zoneRect.y1;\r\n\r\n          /// Get Z from intersection with terrain\r\n          let modelZ = null;\r\n\r\n          let startZ = 100000;\r\n\r\n          let raycaster = new THREE.Raycaster(\r\n            new THREE.Vector3(modelX, startZ, modelY),\r\n            new THREE.Vector3(0, -1, 0)\r\n          );\r\n\r\n          /// TODO: OPT?\r\n          terrainTiles.forEach(function(chunk) {\r\n            if (modelZ === null) {\r\n              let intersections = raycaster.intersectObject(chunk);\r\n              if (intersections.length > 0) {\r\n                modelZ = startZ - intersections[0].distance;\r\n              }\r\n            }\r\n          });\r\n\r\n          /// Get model id\r\n          /// TODO: check with modelIdx = flag & 0xf;\r\n          let modelIdx = 0;\r\n          let model = layer.modelArray[modelIdx];\r\n          let modelFilename = model.filename;\r\n          // let zOffsets = model.zOffsets;\r\n\r\n          // let layerFlags = layer.layerFlags; // NOrmaly 128, 128\r\n\r\n          // TODO: flip z,y?\r\n          let rotRangeX = layer.rotRangeX; // max min\r\n          let rotRangeY = layer.rotRangeY; // max min\r\n          let rotRangeZ = layer.rotRangeZ; // max min\r\n          let scaleRange = layer.scaleRange; // max min\r\n          let fadeRange = layer.fadeRange; // max min\r\n\r\n          // Unused\r\n          // tiling: 3\r\n          // type: 1\r\n          // width: 2\r\n          // radiusGround: 2\r\n\r\n          /// Create modelGroup (this zone only)\r\n          if (!modelGroups[modelFilename]) {\r\n            modelGroups[modelFilename] = [];\r\n          }\r\n\r\n          /// Add entry to model group\r\n          modelGroups[modelFilename].push({\r\n            x: modelX,\r\n            y: modelY,\r\n            z: modelZ,\r\n            rotRangeX: rotRangeX,\r\n            rotRangeY: rotRangeY,\r\n            rotRangeZ: rotRangeZ,\r\n            scaleRange: scaleRange,\r\n            fadeRange: fadeRange\r\n          });\r\n        } /// End if layer\r\n      } /// End if flag != 0\r\n    } /// End for each flag\r\n\r\n    return modelGroups;\r\n  };\r\n}\r\n\r\n/// NOT USED??\r\n// eslint-disable-next-line no-unused-vars\r\nfunction addZoneMeshesToScene(meshes, isCached, position, scale, rotation) {\r\n  /// Called for each mesh in the zone\r\n  /// TODO: Opt opt opt...\r\n\r\n  meshes.forEach(function(mesh) {\r\n    /// Create new mesh if we got back a cached original.\r\n    if (isCached) mesh = new THREE.Mesh(mesh.geometry, mesh.material);\r\n\r\n    /// Scale, position and rotate.\r\n    mesh.scale.set(scale, scale, scale);\r\n    if (rotation) {\r\n      mesh.rotation.order = \"ZXY\";\r\n      mesh.rotation.set(rotation.x, rotation.y, rotation.z);\r\n    }\r\n    mesh.position.set(position.x, position.y, position.z);\r\n\r\n    /// Add to export\r\n    this.getOutput().meshes.push(mesh);\r\n  });\r\n}\r\n\r\n/// DataRenderer inheritance:\r\nZoneRenderer.prototype = Object.create(DataRenderer.prototype);\r\nZoneRenderer.prototype.constructor = ZoneRenderer;\r\n\r\n/**\r\n * Renders all zone meshes in a GW2 map described by the map's \"zon2\" chunk.\r\n * Output fileds generated:\r\n *\r\n * - *meshes* An array of THREE.Mesh objects visualizing all zone models refered by this map.\r\n *\r\n * @async\r\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\r\n */\r\nZoneRenderer.prototype.renderAsync = function(callback) {\r\n  let self = this;\r\n\r\n  /// Set up output array\r\n  self.getOutput().meshes = [];\r\n\r\n  let zoneChunkData = this.mapFile.getChunk(\"zon2\").data;\r\n  let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\r\n  // let terrainChunkData = this.mapFile.getChunk(\"trn\").data;\r\n  let mapRect = parameterChunkData.rect;\r\n\r\n  /// Zone data\r\n  let zones = zoneChunkData.zoneArray;\r\n  let zoneDefs = zoneChunkData.zoneDefArray;\r\n\r\n  /// Render each zone\r\n  let lastPct = -1;\r\n\r\n  /// Main render loop, render each zone\r\n  function stepZone(i) {\r\n    let pct = Math.round((100.0 * i) / zones.length);\r\n    if (lastPct !== pct) {\r\n      self.logger.log(\r\n        T3D.Logger.TYPE_PROGRESS,\r\n        \"Loading 3D Models (Zone)\",\r\n        pct\r\n      );\r\n      lastPct = pct;\r\n    }\r\n\r\n    if (i >= zones.length) {\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    /// Main zone render function call\r\n    self.renderZone(zones[i], zoneDefs, mapRect, stepZone.bind(self, i + 1));\r\n  }\r\n\r\n  stepZone(0);\r\n};\r\n\r\nmodule.exports = ZoneRenderer;\r\n\r\n/// / Not used: zone defintion per chunk data \"images\" 32*32 points\r\n/*\r\n//Total map dx and dy\r\nvar d = terrainChunkHeader.data;\r\nvar pd = parameterChunkHeader.data;\r\nvar dx = (pd.rect.x2-pd.rect.x1);\r\nvar dy = (pd.rect.y2-pd.rect.y1);\r\n\r\n//Each chunk dx and dy\r\n\r\nvar c =1;\r\nvar cdx = c*dx/d.dims.dim1;\r\n\r\nvar cdy = c*dy/d.dims.dim2;\r\n\r\nvar cdx = dx/(d.numChunksD_1*2);\r\nvar cdy =dy/(d.numChunksD_2*2);\r\n\r\nfor(var i=0; i<zoneDefs.length; i++){\r\n\tvar zoneDef = zoneDefs[i];\r\n\r\n\t//TODO: opt!\r\n\tzoneDef.layerDefs.forEach(function(layer){\r\n\r\n\t\tlayer.modelArray.forEach(function(model){\r\n\r\n\t\t});\r\n\r\n\t});\r\n\r\n\tvar chunkMat = new THREE.MeshBasicMaterial(\r\n\t\t{\r\n\t\t\tcolor: 0x00ff00,\r\n\t\t\twireframe:true,\r\n\t\t \topacity: 1.0,\r\n\t\t}\r\n\t);\r\n\r\n\t//TODO: opt!\r\n\r\n\tif(\r\n\t\tzoneDef.token == 597  ||\r\n\t\tzoneDef.token == 1369  ||\r\n\t\tzoneDef.token == 903\r\n\t){\r\n\r\n\t\tzoneDef.pageTable.pageArray.forEach(function(page){\r\n\t\t\tvar flags = page.flags;\r\n\t\t\tvar coord = page.chunkCoord;\r\n\r\n\t\t\t//Hightlight this coord\r\n\t\t\tvar rect = {};\r\n\r\n\t\t\t//var globalOffsetX = pd.rect.x2 - cdx;\r\n\t\t\tvar globalOffsetX = pd.rect.x1 + cdx/2;\r\n\t\t\tvar chunkOffsetX = coord[0] * cdx;\r\n\r\n\t\t\trect.x1  = globalOffsetX + chunkOffsetX;\r\n\r\n\t\t\t///Adjust for odd / even number of chunks\r\n\t\t\tif(d.numChunksD_2 % 2 == 0){\r\n\r\n\t\t\t\tvar globalOffsetY = -pd.rect.y1;\r\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\r\n\r\n\t\t\t\trect.y1  =  chunkOffsetY + globalOffsetY;\r\n\t\t\t}\r\n\t\t\telse{\r\n\r\n\t\t\t\tvar globalOffsetY =  -pd.rect.y1;\r\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\r\n\r\n\t\t\t\trect.y1 = globalOffsetY +  chunkOffsetY;\r\n\t\t\t}\r\n\r\n\t\t\trect.x2 = rect.x1+cdx;\r\n\t\t\trect.y2 = rect.y1+cdy;\r\n\r\n\t\t\tRenderUtils.renderRect(rect, 4000,chunkMat, 4000);\r\n\r\n\t\t\t//for(var j=0; j<flags.length; j++){\r\n\t\t\t//\tif(flags[j]>0){\r\n\t\t\t//\t\tconsole.log(\"Found flag\",flags[j],\"@ zoneDef\",zoneDef.token,\"coord\",coord,\"index\",j);\r\n\t\t\t//\t}\r\n\t\t\t//}\r\n\t\t});\r\n\r\n\t}\r\n\r\n} */\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst HEAD_STRUCT = [\r\n  \"type\",\r\n  \"cstring:4\",\r\n  \"chunkDataSize\",\r\n  \"uint32\",\r\n  \"chunkVersion\",\r\n  \"uint16\",\r\n  \"chunkHeaderSize\",\r\n  \"uint16\",\r\n  \"offsetTableOffset\",\r\n  \"uint32\"\r\n];\r\n\r\n/**\r\n * Settings for resolving conflicting chunk names in different files.\r\n * @private\r\n * @property DUPLICATE_SETTINGS\r\n * @type {Object}\r\n */\r\nlet DUPLICATE_SETTINGS;\r\n\r\n// Replacement for DUPLICATE_SETTINGS, based on the name of the root property.\r\nconst PACKTOCHUNK = [\r\n  { pack: \"MODL\", chunk: \"ANIM\", root: \"ModelFileAnimation\" },\r\n  { pack: \"MODL\", chunk: \"GAME\", root: \"ModelFileGame\" },\r\n  { pack: \"MODL\", chunk: \"SKEL\", root: \"ModelFileSkeleton\" },\r\n  { pack: \"MODL\", chunk: \"TOOL\", root: \"ModelFileTool\" },\r\n  { pack: \"cntc\", chunk: \"Main\", root: \"PackContent\" },\r\n  { pack: \"mMet\", chunk: \"Main\", root: \"PackMapMetadata\" },\r\n  { pack: \"AMAT\", chunk: \"TOOL\", root: \"AmatToolParams\" },\r\n  { pack: \"cmaC\", chunk: \"main\", root: \"CollideModelManifest\" }\r\n];\r\n\r\n// Builds the DUPLICATE_SETTINGS based on the provided T3D.formats.\r\n// Required to be done dynamically since the 32 bit and 64bits have different ordering\r\nfunction genDuplicateSettings() {\r\n  // Early return if the settings have been already generated\r\n  if (DUPLICATE_SETTINGS) return;\r\n\r\n  function getRootName(definition) {\r\n    let a = new definition();\r\n    return Object.keys(a).filter(v => {\r\n      return a[v] === a.__root && v !== \"__root\";\r\n    })[0];\r\n  }\r\n\r\n  DUPLICATE_SETTINGS = {};\r\n  for (let setting of PACKTOCHUNK) {\r\n    let regex = new RegExp(`^${setting.root}(V[0-9]*)?$`);\r\n    let chunkDef = T3D.formats.filter(v => {\r\n      return v.name === setting.chunk;\r\n    });\r\n\r\n    for (let defsIdx in chunkDef) {\r\n      let defs = chunkDef[defsIdx].versions;\r\n      let lastVersion = defs[Object.keys(defs).pop()];\r\n      let rootName = getRootName(lastVersion);\r\n      if (rootName.match(regex)) {\r\n        if (!DUPLICATE_SETTINGS[setting.chunk]) {\r\n          DUPLICATE_SETTINGS[setting.chunk] = [];\r\n        }\r\n        DUPLICATE_SETTINGS[setting.chunk][defsIdx] = setting.pack;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Basic chunk parsing functionality for Guild Wars 2 file chunks\r\n *\r\n * @constructor\r\n * @param {DataStream} ds A DataStream containing deflated chunk binary data.\r\n * @param {Number} addr Offset of chunk start within the DataStream\r\n */\r\nclass GW2Chunk {\r\n  constructor(ds, addr) {\r\n    // Early returns if already called, it defines the DUPLICATE_SETTINGS variable\r\n    genDuplicateSettings();\r\n\r\n    /**\r\n     * @property {DataStream} ds The DataStream data source used by this chunk.\r\n     */\r\n    this.ds = ds;\r\n\r\n    /**\r\n     * @property {Number} addr The address to this Chunk within ds.\r\n     */\r\n    this.addr = addr;\r\n\r\n    /**\r\n     * @property {Object} data The typed data read from the body of this chunk.\r\n     */\r\n    this.data = null;\r\n\r\n    /**\r\n     * @property {Number} headerLength The length in bytes of the chunk header.\r\n     */\r\n    this.headerLength = NaN;\r\n\r\n    /**\r\n     * @property {Object} header Chunk header data.\r\n     */\r\n    this.loadHead();\r\n  }\r\n\r\n  /**\r\n   * Parses the chunk header data, populating the header property.\r\n   */\r\n  loadHead() {\r\n    this.ds.seek(this.addr);\r\n    this.header = this.ds.readStruct(HEAD_STRUCT);\r\n\r\n    this.headerLength = this.ds.position - this.addr;\r\n  }\r\n\r\n  /**\r\n   * @param  {String} fileType The main type of the pack file containing this chunk.\r\n   * Used for resolving chunk naming conflicts between pack file types.\r\n   * @return {Array}\tDataStream formatted array describing the data\r\n   * sctructures of this chunk\r\n   */\r\n  getDefinition(fileType) {\r\n    /// Normally we're looking for the 0th occurance\r\n    /// But some chunk names occur multiple times and we're interrested\r\n    /// in the N:th occurance of the definition.\r\n    ///\r\n    /// I've no idea how this is automated, for now just use the\r\n    /// settings object I've put together from experience.\r\n    let useNthIndex = 0;\r\n\r\n    /// If this chunk has multiple definitions\r\n    /// get to know what def to use...\r\n    let fileTypes = DUPLICATE_SETTINGS[this.header.type];\r\n    if (fileTypes) {\r\n      useNthIndex = -1;\r\n\r\n      /// Check what file name entry matches this file name\r\n      for (let i = 0; i < fileTypes.length && useNthIndex === -1; i++) {\r\n        let ft = fileTypes[i];\r\n\r\n        if (ft === fileType) {\r\n          useNthIndex = i;\r\n        }\r\n      }\r\n\r\n      /// We didnt find this file name!\r\n      /// TODO: if you get this error, please update the DUPLICATE_SETTINGS above\r\n      if (useNthIndex === -1) {\r\n        throw new Error(\"We didnt find this file name!\");\r\n        //debugger;\r\n      }\r\n    }\r\n\r\n    let defsFound = 0;\r\n    for (let i = 0; i < T3D.formats.length; i++) {\r\n      let f = T3D.formats[i];\r\n\r\n      /// Chunk name needs to match\r\n      if (f.name === this.header.type) {\r\n        /// There needs to be a chunk def version matching the one specifiend\r\n        ///\r\n        /// AND If this is the Nth occurance of the chunk definition\r\n        /// and we're looking for the Nth occurance, return it.\r\n        ///\r\n        /// chunkVersion in the dat uses 0 indexing\r\n        if (defsFound === useNthIndex && f.versions[this.header.chunkVersion]) {\r\n          return new f.versions[this.header.chunkVersion]().__root;\r\n        }\r\n\r\n        defsFound++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses the chunk main data, populating the data property.\r\n   *\r\n   * @param  {String} fileType The main type of the pack file containing this chunk.\r\n   * Used for resolving chunk naming conflicts between pack file types when\r\n   * looking up the structure definition for this chunk.\r\n   */\r\n  loadData(fileType) {\r\n    let def = this.getDefinition(fileType);\r\n\r\n    if (def) {\r\n      this.ds.seek(this.addr + this.headerLength);\r\n      this.data = this.ds.readStruct(def);\r\n    } else {\r\n      T3D.Logger.log(\r\n        T3D.Logger.TYPE_WARNING,\r\n        \"Could not find a definition for chunk\",\r\n        this.header.type,\r\n        \"version\",\r\n        this.header.chunkVersion,\r\n        \"file name\",\r\n        fileType\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves the next chunk is the datastream. In practice this means the next chunk\r\n   * within the same pack file.\r\n   *\r\n   * @return {GW2Chunk} The next chunk if any, otherwise null.\r\n   */\r\n  next() {\r\n    try {\r\n      // Calculate actual data size, as mChunkDataSize\r\n      // does not count the size of some header variables\r\n      return new GW2Chunk(this.ds, this.addr + 8 + this.header.chunkDataSize);\r\n    } catch (e) {\r\n      /// Out of bounds probably\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\nmodule.exports = GW2Chunk;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst Chunk = require(\"./GW2Chunk\");\r\n\r\nconst HEAD_STRUCT = [\r\n  \"identifier\",\r\n  \"cstring:2\",\r\n  \"unknownField1\",\r\n  \"uint16\",\r\n  \"unknownField2\",\r\n  \"uint16\",\r\n  \"pkFileVersion\",\r\n  \"uint16\",\r\n  \"type\",\r\n  \"cstring:4\"\r\n];\r\n\r\n/**\r\n * Basic header and chunk parsing functionality for Guild Wars 2 pack files (PF)\r\n *\r\n * @constructor\r\n * @param {DataStream} ds A DataStream containing deflated file binary data.\r\n * @param {Number} addr Offset of file start within the DataStream\r\n * @param {boolean} noChunks If true, the file does not parse its\r\n * chunks on creation.\r\n */\r\nclass GW2File {\r\n  constructor(ds, addr, noChunks) {\r\n    /**\r\n     * @property {DataStream} ds The DataStream data source used by this file.\r\n     */\r\n    this.ds = ds;\r\n\r\n    /**\r\n     * @property {Number} addr The address to this File within ds.\r\n     */\r\n    this.addr = addr;\r\n\r\n    /// Not used anymore I think\r\n    this.data = null;\r\n\r\n    /**\r\n     * @property {Number} headerLength The length in bytes of the file header.\r\n     */\r\n    this.headerLength = NaN;\r\n\r\n    /**\r\n     * All {{#crossLink \"GW2Chunk\"}}chunks{{/crossLink}} contained in the file.\r\n     *\r\n     * @property chunks\r\n     * @type GW2Chunk[]\r\n     */\r\n    this.chunks = [];\r\n\r\n    /**\r\n     * @property {Object} header Chunk header data.\r\n     */\r\n    this.readHead();\r\n\r\n    if (!noChunks) {\r\n      this.readChunks();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses the file header data, populating the header property.\r\n   */\r\n  readHead() {\r\n    this.ds.seek(this.addr);\r\n    this.header = this.ds.readStruct(HEAD_STRUCT);\r\n    this.headerLength = this.ds.position - this.addr;\r\n  }\r\n\r\n  /**\r\n   * Parses the file headers and populates the chunks property.\r\n   */\r\n  readChunks() {\r\n    /// Reset chunks\r\n    this.chunks = [];\r\n\r\n    // var structs = this.getChunkStructs && this.getChunkStructs();\r\n\r\n    /// Load basic Chunk in order to read the chunk header.\r\n    let ch = new Chunk(this.ds, this.headerLength + this.addr);\r\n\r\n    // while(structs && ch!=null && ch.header.type){\r\n    while (ch !== null && ch.header.type) {\r\n      /// Load data and pass file type if we need to determine what chunk entry to use\r\n      /// (Some chunks in different files share the same chunk name)\r\n      ch.loadData(this.header.type);\r\n      this.chunks.push(ch);\r\n\r\n      /// Load next basic Chunk in order to read the chunk header.\r\n      ch = ch.next();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a GW2Chunk from this file\r\n   *\r\n   * @param  {String} type The name, or type of the desired chunk.\r\n   * @return {GW2Chunk} The first GW2Chunk in this file matching the type name, or null if no matching GW2Chunk was found.\r\n   */\r\n  getChunk(type) {\r\n    for (let i = 0; i < this.chunks.length; i++) {\r\n      if (this.chunks[i].header.type.toLowerCase() === type.toLowerCase()) {\r\n        return this.chunks[i];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Provides a list of known header types and their parsing structure. Should be defined by each file type individually.\r\n   *\r\n   * @return {Object} An object mapping chunk identifiers to DataStream structure descriptors.\r\n   */\r\n  getChunkStructs() {\r\n    return {};\r\n  }\r\n}\r\n\r\nmodule.exports = GW2File;\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/*\r\n\tguid 1683952224941671000 is fucked up floor in SAB HUB\r\n\tmaterialFilename for that mesh is 564821, shared with lots of stuff\r\n\tlod 1 and 2 are both 0\r\n\tmaterial flags is 2056\r\n*/\r\n\r\n/**\r\n * Collection of methods for generating THREE materials and textures\r\n * from Guild Wars 2 data formats.\r\n * @namespace MaterialUtils\r\n */\r\n\r\n/**\r\n * Builds a custom vertex shader for a given number of uv cannels.\r\n * WIP not implemented yet!\r\n *\r\n * @memberof MaterialUtils\r\n * @param  {Number} numUv Number of UV channels used by this shader\r\n * @return {String}       Genereted vertex shader source\r\n */\r\nfunction buildVS(numUv) {\r\n  let vdefs = \"\";\r\n  let adefs = \"\";\r\n  let reads = \"\";\r\n  for (let i = 0; i < numUv; i++) {\r\n    vdefs += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\r\n\r\n    /// uv and uv2 are defined by THREE\r\n    if (i > 1) adefs += \"attribute vec2 uv\" + (i + 1) + \";\\n\";\r\n\r\n    reads += \"vUv_\" + (i + 1) + \" = uv\" + (i > 0 ? i + 1 : \"\") + \";\\n\";\r\n  }\r\n\r\n  return (\r\n    adefs +\r\n    vdefs +\r\n    \"void main()\\n\" +\r\n    \"{\\n\" +\r\n    reads +\r\n    \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\" +\r\n    \"gl_Position = projectionMatrix * mvPosition;\\n\" +\r\n    \"}\"\r\n  );\r\n}\r\n\r\n/**\r\n * Generate a texture of a specified color, used to be part of THREEjs\r\n *\r\n * @memberof MaterialUtils\r\n * @param {Number} width\r\n * @param {Number} height\r\n * @param {THREE.Color} color\r\n * @returns {THREE.DataTexture}\r\n */\r\nfunction generateDataTexture(width, height, color) {\r\n  // create a buffer with color data\r\n  let size = width * height;\r\n  let data = new Uint8Array(4 * size);\r\n  let r = Math.floor(color.r * 255);\r\n  let g = Math.floor(color.g * 255);\r\n  let b = Math.floor(color.b * 255);\r\n  let a = 255;\r\n\r\n  for (let i = 0; i < size; i++) {\r\n    let stride = i * 4;\r\n\r\n    data[stride] = r;\r\n    data[stride + 1] = g;\r\n    data[stride + 2] = b;\r\n    data[stride + 3] = a;\r\n  }\r\n  // used the buffer to create a DataTexture\r\n  return new THREE.DataTexture(data, width, height, THREE.RGBAFormat);\r\n}\r\n\r\n/**\r\n * Builds a custom pixel shader for a given number of uv cannels.\r\n * WIP not implemented yet!\r\n *\r\n * @memberof MaterialUtils\r\n * @param  {Array}  textures  THREE textures\r\n * @param  {Number} numUv     Number of UV channels used by this shader\r\n * @param  {Number} alphaTest Texture see-trough alpha treshold\r\n * @param  {any} lightMap  TODO\r\n * @returns {string}\r\n */\r\nfunction buildPS(textures, numUv, alphaTest, lightMap) {\r\n  let t1uv = \"vUv_\" + (textures[0].uvIdx + 1);\r\n\r\n  let discard = \"\";\r\n\r\n  if (alphaTest) {\r\n    discard = \"    if (c1.a < 0.5) \\n\" + \"       discard;\\n\";\r\n  }\r\n\r\n  /// Color from 1st text or lighted by 2nd?\r\n  let writeColor = \"gl_FragColor = c1;\\n\";\r\n\r\n  if (lightMap) {\r\n    let texIdx = 0;\r\n    // var t2uv = \"vUv_4\";//+(3-textures[texIdx].uvIdx+1);\r\n    let t2uv = \"vUv_1\"; // + (textures[texIdx].uvIdx+1);\r\n    // console.log(\"t2uv\",t2uv);\r\n\r\n    writeColor =\r\n      \"   vec4 c2 = texture2D( texture\" +\r\n      (texIdx + 1) +\r\n      \", \" +\r\n      t2uv +\r\n      \" );\\n\" +\r\n      \"     gl_FragColor = c2;\\n\";\r\n    // \"     gl_FragColor = vec4(c2.rgb * c1.r/.5, c2.a);\\n\";\r\n  }\r\n\r\n  let uniforms = \"\";\r\n  textures.forEach(function(t, idx) {\r\n    uniforms += \"uniform sampler2D texture\" + (idx + 1) + \";\\n\";\r\n  });\r\n  /* uniforms += \"uniform sampler2D texture1;\\n\";\r\n\tif(lightMap)\r\n\t\tuniforms += \"uniform sampler2D texture2;\\n\"; */\r\n\r\n  let varyings = \"\";\r\n  for (let i = 0; i < numUv; i++) {\r\n    varyings += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\r\n  }\r\n\r\n  return (\r\n    uniforms +\r\n    varyings +\r\n    \"void main( void ) {\\n\" +\r\n    \"    vec4 c1 = texture2D( texture1, \" +\r\n    t1uv +\r\n    \" );\\n\" +\r\n    discard +\r\n    writeColor +\r\n    \"}\"\r\n  );\r\n}\r\n\r\n/**\r\n * WIP, concept for generatin materials to render multi UV chanelled meshes.\r\n *\r\n * @memberof MaterialUtils\r\n * @param  {Array} \ttextures  THREE texture\r\n * @param  {Number} numUV     Number of UV channels used by this shader\r\n * @param  {Number} alphaTest Texture see-trough alpha treshold\r\n * @return {THREE.ShaderMaterial} Generated shader\r\n */\r\nfunction getUVMat(textures, numUV, alphaTest) {\r\n  let lightMap = false;\r\n  let uniforms = {};\r\n\r\n  textures.forEach(function(t, idx) {\r\n    uniforms[\"texture\" + idx] = { type: \"t\", value: t };\r\n  });\r\n\r\n  if (textures.length > 1) {\r\n    lightMap = true;\r\n  }\r\n\r\n  let attributes = {};\r\n\r\n  for (let i = 2; i < numUV; i++) {\r\n    attributes[\"uv\" + (i + 1)] = { type: \"v2\", value: [] };\r\n  }\r\n\r\n  let vs = buildVS(numUV);\r\n\r\n  return new THREE.ShaderMaterial({\r\n    uniforms: uniforms,\r\n    vertexShader: vs,\r\n    fragmentShader: buildPS(textures, numUV, alphaTest, lightMap),\r\n    attributes: attributes,\r\n    side: THREE.FrontSide\r\n  });\r\n}\r\n\r\n/**\r\n * Builds a THREE texture from a ModelMaterialData by reading settings and\r\n * loading any required data from the localReader. Uses sharedTextures for\r\n * texture caching.\r\n *\r\n * This method is full of guesses and estimations, and could be improved on\r\n * a lot, allowing rendering of multi UV channeled materials, or special\r\n * materials like custom color chanelled gear.\r\n *\r\n * @memberof MaterialUtils\r\n * @param  {ModelMaterialData} material \tA value object often automaticaly\r\n *                                       \tgenerated by a\r\n *                                       \t{{#crossLink \"GW2Chunk\"}}{{/crossLink}}\r\n *                                       \tstructure definitions can be found in\r\n *                                       \tAllFormats.js, look for the latest\r\n *                                       \tversion of ModelMaterialData\r\n *\r\n * @param  {GW2File} materialFile   A GW2File instance, must be of type AMAT\r\n * @param  {LocalReader} localReader The LocalReader to load the file contents from.\r\n * @param  {Object} sharedTextures  Value Object for keeping the texture cache\r\n * @return {THREE.Material}         A THREE Material with the generated contents and settings.\r\n */\r\nfunction getMaterial(material, materialFile, localReader, sharedTextures) {\r\n  if (!materialFile) return;\r\n\r\n  let dxChunk = materialFile.getChunk(\"dx9s\");\r\n  let grChunk = materialFile.getChunk(\"grmt\");\r\n\r\n  /// Append all textures to the custom material\r\n  let finalTextures = [];\r\n\r\n  // Some materials don't use textures..\r\n  if (\r\n    material &&\r\n    material.textures.length /* && material.textures[texIndex] */\r\n  ) {\r\n    /// TODO: check for flags!\r\n    ///\r\n    /// techinques[] -> passes[] -> effects[] -> samplerIndex[]\r\n    ///\r\n    // console.log(\"num effects\",dxChunk.data.techniques[0].passes[0].effects.length);\r\n\r\n    // if(grChunk.data.flags!=76)\r\n    //\treturn;\r\n\r\n    /// 3 teqs : high medium low\t\t\t\t\t\t\t\tGRAPHICS LEVEL SETTINGS\r\n    /// 1 passes\t\t\t\t\t\t\t\t\t\t\t\tDON'T CARE\r\n    /// 15 effects\t\t\tEach effect has a pixel shader \t\tHOW??\r\n    /// 1 or 2 sampler indices \t\t\t\t\t\t\t\t\tUSE ALL! (Multi material)\r\n\r\n    let effects = dxChunk.data.techniques[0].passes[0].effects;\r\n    // var effect = effects[10];\r\n    let effect = effects[0];\r\n\r\n    //let shader = dxChunk.data.shaders[effect.pixelShader];\r\n\r\n    /* effects.forEach(function (eff) {\r\n\t\t\tif(eff.samplerIndex.length > effect.samplerIndex.length)\r\n\t\t\t\teffect = eff;\r\n\t\t}); */\r\n    // var samplerIdx = effect.samplerIndex[0];\r\n\r\n    let samplerTextures = [];\r\n    let textureToken;\r\n    let samplerTex;\r\n    for (let i = 0; i < effect.samplerIndex.length; i++) {\r\n      let samplerIdx = effect.samplerIndex[i];\r\n      let sampler = dxChunk.data.samplers[samplerIdx];\r\n\r\n      /// SHOULD NEVER HAPPEN, hide mesh!\r\n      if (!sampler) continue; // return;\r\n\r\n      textureToken = sampler && grChunk.data.texTokens[sampler.textureIndex];\r\n      if (!textureToken) textureToken = \"0-0\";\r\n      /* else\r\n\t\t\t\ttextureToken =textureToken.val; */\r\n\r\n      /// Find the texture reffered by this sampler\r\n      samplerTex = null;\r\n\r\n      material.textures.forEach(function(tex /*, index*/) {\r\n        /// Seems like only 1st part of token is used...\r\n        if (\r\n          !samplerTex &&\r\n          tex.token.split(\"-\")[0] === textureToken.split(\"-\")[0]\r\n        ) {\r\n          // console.log(\"TEX match\",tex.token, textureToken)\r\n          samplerTex = tex;\r\n        }\r\n      });\r\n\r\n      /// Add this sampler's texture to the collection of all textures\r\n      if (samplerTex) {\r\n        samplerTextures.push(samplerTex);\r\n      } else {\r\n        /// FALLBACK, just guess what texture we should use\r\n        if (sampler) {\r\n          samplerTextures.push(material.textures[sampler.textureIndex]);\r\n        } else if (material.textures.length > 0) {\r\n          samplerTextures.push(material.textures[0]);\r\n        } else return;\r\n      }\r\n    } /// END for each sampler index in effect\r\n\r\n    /// We now have all textures\r\n    // console.log(\"textures from sampler\", samplerTextures);\r\n\r\n    /// Fallback to using whatever texture there is.\r\n    if (samplerTextures.length <= 0) {\r\n      return;\r\n      // mainTex =  material.textures[0];\r\n    }\r\n\r\n    // console.log(\"num samplers \",samplerTextures.length);\r\n    samplerTextures.forEach(function(texture, idx) {\r\n      if (!texture) return;\r\n\r\n      /// Set texture \"URL\"\r\n      let texURL = texture && texture.filename;\r\n\r\n      /// Load texture from RAM or local reader:\r\n      finalTextures[idx] = getTexture(texURL, localReader, sharedTextures);\r\n      if (finalTextures[idx]) {\r\n        finalTextures[idx].uvIdx = texture.uvPSInputIndex;\r\n      }\r\n    });\r\n  } /// End if material and texture\r\n\r\n  let finalMaterial;\r\n\r\n  /// Create custom shader material if there are textures\r\n  if (finalTextures) {\r\n    // TODO: make this work!\r\n    //eslint-disable-next-line no-constant-condition\r\n    if (false && finalTextures.length > 0) {\r\n      finalMaterial = getUVMat(\r\n        finalTextures,\r\n        material.texCoordCount,\r\n        grChunk.data.flags !== 16460\r\n      );\r\n    } else {\r\n      let ft = false;\r\n      let nt = false;\r\n      material.textures.forEach(function(t) {\r\n        // Flag for diffuse map\r\n        if (!ft && t.token.split(\"-\")[0] === \"1733499172\") ft = t;\r\n\r\n        // Flag for normal map\r\n        if (!nt && t.token.split(\"-\")[0] === \"404146670\") nt = t;\r\n      });\r\n\r\n      if (!ft || ft.filename <= 0) return;\r\n\r\n      finalMaterial = new THREE.MeshPhongMaterial({\r\n        side: THREE.FrontSide,\r\n        map: getTexture(ft.filename, localReader, sharedTextures)\r\n      });\r\n      if (nt) {\r\n        let normalMap = getTexture(nt.filename, localReader, sharedTextures);\r\n        normalMap.flipY = true;\r\n        finalMaterial.normalMap = normalMap;\r\n      }\r\n\r\n      finalMaterial.textureFilename = ft.filename;\r\n      if (grChunk.data.flags !== 16460) {\r\n        // console.log(\"Setting alpha flag for \",grChunk.data.flags)\r\n        finalMaterial.alphaTest = 0.05;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// Fallback material is monocolored red\r\n  else {\r\n    finalMaterial = new THREE.MeshBasicMaterial({\r\n      side: THREE.FrontSide,\r\n      color: 0xff0000,\r\n      shading: THREE.FlatShading\r\n    });\r\n  }\r\n\r\n  finalMaterial.needsUpdate = true;\r\n\r\n  /// Set material props\r\n  /// disable for now in order for custom shaders not to fuck up\r\n\r\n  if (material) {\r\n    let alphaMask0 = 0x0001; // + 0x0100 + 0x0200;\r\n    let alphaMask1 = 0x0010;\r\n    let alphaMask2 = 0x0100 + 0x0200;\r\n    //let alphaMask2b = 0x0200;\r\n\r\n    grChunk = materialFile.getChunk(\"grmt\");\r\n\r\n    // Enable alpha test for transparent flags\r\n    if (\r\n      material.materialFlags & alphaMask0 ||\r\n      material.materialFlags & alphaMask1 ||\r\n      material.materialFlags & alphaMask2 // && solidColor != null\r\n    ) {\r\n      // return;\r\n      // mesh.material.transparent = true;\r\n      // mesh.material.opacity = 2.0;\r\n      // var clr = solidColor;\r\n      // var propAlpha = 0;\r\n      /// Backgroud color adds to alpha\r\n      // if( mesh.materialFlags == 2569  ){\r\n      /// This is rly just guesswork\r\n      /// Check material flag  2568 (as int) and compare material filename 27353 to 20041\r\n      /// Same flags but some have alpha and some don't\r\n      // if( mesh.materialFlags & alphaMask2b  ){\r\n      //\tpropAlpha =  (clr[3] - 128)/128;\r\n      //\t//propAlpha = Math.max(0,propAlpha);\r\n      // }\r\n      // mesh.material.alphaTest = Math.max(0, 0.1 );//- propAlpha*2);\r\n    }\r\n\r\n    /// GRCHUNK -> DATA -> FLAGS\r\n\r\n    /// HAS LIGHT - TEX - ? - EMISSIVE16460\r\n    ///\r\n\r\n    /// 56533 LOD FOR TOMBSTONE?\r\n\r\n    //\t16460\t\t\t0100 0000 0100 1100\t\t\t\"standard\" stuff rendering OK in SAB (no alpha test)\r\n\r\n    //\r\n    //\t16452(SAB)\t\t0100 0000 0100 0100\t\t\tyellow numbers in sab signs\r\n    //\t16448(SAB)\t\t0100 0000 0100 0000\t\t\tfaces on rocks, cloudmen, skybox portal images, holes in walls, floor plates...\r\n    //\t\t\t\t\t\t\t\t\t\t\t\tno lighting??\r\n    //\r\n    //\t 8268\t\t\t0010 0000 0100 1100\r\n    //\t 3392\t\t\t0000 1101 0100 0000\t\t\tMoto machine light bulbs\r\n    //\t 2380\t\t\t0000 1001 0100 1100\r\n    //\t 2368\t\t\t0000 1001 0100 0000\t\t\tFountain water with rings, portal border and circular \"light\"\r\n    //\t  332\t\t\t0000 0001 0100 1100\r\n    //\t  324\t\t\t0000 0001 0100 0100\t\t\tMoto face sprites\r\n    //\r\n    //\t  320(SAB)\t\t0000 0001 0100 0000\t\t\tportal textures (normal maps ish)\r\n    //\r\n    //\t   76\t\t\t0000 0000 0100 1100\t\t\tLOTS OF STUFF\r\n    //\t   \t\t\t\t\t\t\t\t\t\t\tTree leaves, ground, hills, some roofs, flags, street lights\r\n    //\t   \t\t\t\t\t\t\t\t\t\t\tsheild textures, some fences, water tops, waterfall\r\n    //\r\n    //\t   \t\t\t\t\t\t\t\t\t\t\tIN KHYLO \"everything with alpha\"\r\n    //\r\n    //\r\n    //\t   68\t\t\t0000 0000 0100 0100\t\t\tSome flowers (lo res?) fountain edges foam\r\n    //\r\n    //\t   64(SAB)\t\t0000 0000 0100 0000\t\t\tclouds, sun iamge\r\n\r\n    let lightMask = 8;\r\n\r\n    let knownFileFlags = [\r\n      16460,\r\n      16452,\r\n      16448,\r\n      8268,\r\n      3392,\r\n      2380,\r\n      2368,\r\n      332,\r\n      324,\r\n      320,\r\n      76,\r\n      68,\r\n      64\r\n    ];\r\n\r\n    if (knownFileFlags.indexOf(grChunk.data.flags) < 0) {\r\n      T3D.Logger.log(\r\n        T3D.Logger.TYPE_WARNING,\r\n        \"unknown GR flag\",\r\n        grChunk.data.flags\r\n      );\r\n    }\r\n\r\n    if (!(grChunk.data.flags & lightMask)) {\r\n      // debugger;\r\n      // console.log(\"no light\");\r\n      finalMaterial = new THREE.MeshBasicMaterial({\r\n        side: THREE.FrontSide,\r\n        map: finalMaterial.map\r\n      });\r\n    }\r\n\r\n    if (grChunk.data.flags !== 16460) {\r\n      finalMaterial.alphaTest = 0.05;\r\n    }\r\n  } /// End if material\r\n\r\n  return finalMaterial;\r\n}\r\n\r\n/**\r\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\r\n * Any loaded tetures are added to sharedTextures, allowing for texture caching and fewer reads.\r\n *\r\n * @memberof MaterialUtils\r\n * @param  {Number} texURL         The fileId or baseId of the file to load image data from.\r\n * @param  {LocalReader} localReader    The LocalReader to load the file contents from.\r\n * @param  {Object} sharedTextures Value Object for keeping the texture cache\r\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\r\n */\r\nfunction getTexture(texURL, localReader, sharedTextures) {\r\n  let finalTexture;\r\n\r\n  /// Read texture from shared array of loaded textures\r\n  /// or read it from URL and add to shared ones!\r\n  if (texURL && sharedTextures[texURL]) {\r\n    /// Just read from already loaded textures.\r\n    finalTexture = sharedTextures[texURL];\r\n  } else if (texURL) {\r\n    /// Load and add to shared array.\r\n    finalTexture = loadLocalTexture(localReader, texURL);\r\n\r\n    /// Set standard texture functionality.\r\n    finalTexture.wrapT = THREE.RepeatWrapping;\r\n    finalTexture.wrapS = THREE.RepeatWrapping;\r\n    finalTexture.flipY = false;\r\n\r\n    sharedTextures[texURL] = finalTexture;\r\n  }\r\n\r\n  return finalTexture;\r\n}\r\n\r\n/**\r\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\r\n * If you're loading multiple textures, make sure to use\r\n * {{#crossLink \"MaterialUtils/getTexture\"}}{{/crossLink}} that allows you to cache textures.\r\n *\r\n * @memberof MaterialUtils\r\n * @param {LocalReader} localReader - The LocalReader to load the file contents from.\r\n * @param {Number} fileId - The fileId or baseId of the file to load image data from.\r\n * @param {Number} mapping - What THREE mapping the returned texture will use, not implemented.\r\n\r\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\r\n */\r\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror) {\r\n  if (defaultColor === undefined) {\r\n    defaultColor = Math.floor(0xffffff * Math.random());\r\n  }\r\n\r\n  /// Temporary texture that will be returned by the function.\r\n  /// Color is randomized in order to differentiate different textures during loading.\r\n  let texture = generateDataTexture(\r\n    1, // Width\r\n    1, // Height\r\n    new THREE.Color(defaultColor) // Color\r\n  );\r\n\r\n  // Threejs r71 is using these settings by default, r72+ changed it\r\n  texture.minFilter = THREE.LinearMipMapLinearFilter;\r\n  texture.magFilter = THREE.LinearFilter;\r\n  texture.generateMipmaps = true;\r\n  texture.flipY = true;\r\n\r\n  /// Only allow non-zero fileId, otherwise jsut return static texture\r\n  if (parseInt(fileId) <= 0) {\r\n    if (onerror) onerror();\r\n    return texture;\r\n  }\r\n\r\n  /// Load file using LocalReader.\r\n  localReader.loadTextureFile(fileId, function(\r\n    inflatedData,\r\n    dxtType,\r\n    imageWidth,\r\n    imageHeigth\r\n  ) {\r\n    /// Require infalted data to be returned.\r\n    if (!inflatedData) {\r\n      if (onerror) onerror();\r\n      return;\r\n    }\r\n\r\n    /// Create image using returned data.\r\n    let image = {\r\n      data: new Uint8Array(inflatedData),\r\n      width: imageWidth,\r\n      height: imageHeigth\r\n    };\r\n\r\n    /// Use RGBA for all textures for now...\r\n    /// TODO: don't use alpha for some formats!\r\n    texture.format =\r\n      //eslint-disable-next-line no-constant-condition\r\n      dxtType === 3 || dxtType === 5 || true\r\n        ? THREE.RGBAFormat\r\n        : THREE.RGBFormat;\r\n\r\n    /// Update texture with the loaded image.\r\n    texture.image = image;\r\n    texture.needsUpdate = true;\r\n  });\r\n\r\n  /// Return texture with temporary content.\r\n  return texture;\r\n}\r\n\r\nmodule.exports = {\r\n  buildVS: buildVS,\r\n  generateDataTexture: generateDataTexture,\r\n  buildPS: buildPS,\r\n  getUVMat: getUVMat,\r\n  getMaterial: getMaterial,\r\n  loadLocalTexture: loadLocalTexture\r\n};\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst base32Max = Math.pow(2, 32);\r\n\r\n/**\r\n * Collection Math and sorting methods\r\n * @namespace MathUtils\r\n */\r\n\r\n/**\r\n * Takes an integer and calculates what the 16 bit float\r\n * representation of the binary data used to read the integer is.\r\n *\r\n * @memberof MathUtils\r\n * @param  {Number} h Integer value\r\n * @return {Number} Float value\r\n */\r\nfunction f16(h) {\r\n  let s = (h & 0x8000) >> 15;\r\n  let e = (h & 0x7c00) >> 10;\r\n  let f = h & 0x03ff;\r\n\r\n  if (e === 0) {\r\n    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n  } else if (e === 0x1f) {\r\n    return f ? NaN : (s ? -1 : 1) * Infinity;\r\n  }\r\n\r\n  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\r\n}\r\n\r\n/**\r\n * Calculates the number of binary ones present in the data used to\r\n * generate the input integer.\r\n *\r\n * @memberof MathUtils\r\n * @param  {Number} bits Integer\r\n * @return {Number}      Number of binary ones in the data\r\n */\r\nfunction popcount(bits) {\r\n  let SK5 = 0x55555555;\r\n  let SK3 = 0x33333333;\r\n  let SKF0 = 0x0f0f0f0f;\r\n  // let SKFF = 0xff00ff\r\n\r\n  bits -= (bits >> 1) & SK5;\r\n  bits = (bits & SK3) + ((bits >> 2) & SK3);\r\n  bits = (bits & SKF0) + ((bits >> 4) & SKF0);\r\n  bits += bits >> 8;\r\n\r\n  return (bits + (bits >> 15)) & 63;\r\n}\r\n\r\n/**\r\n * Calculates the 64 bit integer value of two 32 bit integers. Only works up to\r\n * the limit of the javascript Number maximum value.\r\n *\r\n * @memberof MathUtils\r\n * @param  {Number[]} arr     Input integers, length should be 2.\r\n * @return {Number}      64 bit representation of the two integers.\r\n */\r\nfunction arr32To64(arr) {\r\n  /// Re-read as uint64 (still little endian)\r\n  /// Warn: this will not work for ~50+ bit longs cus all JS numbers are 64 bit floats...\r\n  return base32Max * arr[1] + arr[0];\r\n}\r\n\r\n/**\r\n * Sorts an array and returns unique values only.\r\n *\r\n * @memberof MathUtils\r\n * @param  {Array} arr_in     Input array\r\n * @param  {Function} comparator A comparator function between the objects in arr_in\r\n * @return {Array}            Sorted and unique value.\r\n */\r\nfunction sort_unique(arr_in, comparator) {\r\n  let arr = Array.prototype.sort.call(arr_in, comparator);\r\n\r\n  let u = {};\r\n  let a = [];\r\n  for (let i = 0, l = arr.length; i < l; ++i) {\r\n    // eslint-disable-next-line no-prototype-builtins\r\n    if (u.hasOwnProperty(arr[i])) {\r\n      continue;\r\n    }\r\n    a.push(arr[i]);\r\n    u[arr[i]] = 1;\r\n  }\r\n\r\n  return a;\r\n}\r\n\r\nmodule.exports = {\r\n  f16: f16,\r\n  popcount: popcount,\r\n  arr32To64: arr32To64,\r\n  sort_unique: sort_unique\r\n};\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/**\r\n * @namespace ParserUtils\r\n */\r\n\r\n/**\r\n * Collection of methods used for parsing complex data types from the .dat\r\n *\r\n * Most of these methods are only refered by the automatically generated script\r\n * AllFormats.js\r\n *\r\n */\r\n\r\nmodule.exports = {\r\n  /**\r\n   * Generates a function for reading an array using DataStream\r\n   *\r\n   * @param  {Array} structDef DataStream formatted structure definition\r\n   *                           for the items in the array.\r\n   * @param  {Number} maxCount The maximum allowed length of the array.\r\n   *                           Allows any length if left unspecified.\r\n   * @return {Function}        The generated parsing function.\r\n   */\r\n  getArrayReader: function(structDef, maxCount) {\r\n    return function(ds, struct) {\r\n      let ret = [];\r\n      try {\r\n        let arr_len = ds.readUint32();\r\n        let offset = ds.readUint32();\r\n        if (offset === 0) {\r\n          return ret;\r\n        }\r\n        let arr_ptr = ds.position - 4 + offset;\r\n        let pos = ds.position;\r\n\r\n        if (maxCount && arr_len > maxCount) {\r\n          throw \"Array length \" +\r\n            arr_len +\r\n            \" exceeded allowed maximum \" +\r\n            maxCount;\r\n        }\r\n\r\n        ds.seek(arr_ptr);\r\n        ret = ds.readType([\"[]\", structDef, arr_len], struct);\r\n        ds.seek(pos);\r\n      } catch (e) {\r\n        console.warn(\"getArrayReader Failed loading array\", e);\r\n        console.warn(\r\n          \"getArrayReader Failed loading array, structDef\",\r\n          structDef\r\n        );\r\n      }\r\n      return ret;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Generates a function for reading a refered array using DataStream\r\n   *\r\n   * @param  {Array} structDef DataStream formatted structure definition\r\n   *                           for the items in the array.\r\n   * @return {Function}        The generated parsing function.\r\n   */\r\n  getRefArrayReader: function(structDef) {\r\n    return function(ds) {\r\n      let ret_arr = [];\r\n\r\n      /// Read array of offsets\r\n      let arr_len = ds.readUint32();\r\n      let arr_ptr = ds.position + ds.readUint32();\r\n\r\n      if (arr_len === 0) {\r\n        return ret_arr;\r\n      }\r\n\r\n      let orgPos = ds.position;\r\n\r\n      /// Go to pointer and read an array of offsets!\r\n      ds.seek(arr_ptr);\r\n      let offsets = ds.readInt32Array(arr_len);\r\n\r\n      // p_data is after having read array\r\n      // var pointer = p_data - 4;\r\n      let pointer = orgPos - 4;\r\n\r\n      // auto offset  = *reinterpret_cast<const int32*>(pointer);\r\n      ds.seek(pointer);\r\n      let offset = ds.readUint32(); /// this should be the same as arr_ptr\r\n\r\n      // pointer     += offset;\r\n      pointer += offset;\r\n\r\n      for (let i = 0; i < offsets.length; i++) {\r\n        if (offsets[i] !== 0) {\r\n          let pos = pointer + i * 4 + offsets[i];\r\n          ds.seek(pos);\r\n\r\n          try {\r\n            ret_arr.push(ds.readStruct(structDef));\r\n          } catch (e) {\r\n            // debugger;\r\n            ret_arr.push(null);\r\n            console.warn(\r\n              \"getRefArrayReader could not find refered data at offset\",\r\n              offsets[i],\r\n              e\r\n            );\r\n          }\r\n        }\r\n      } /// End for each offset\r\n\r\n      ds.seek(orgPos);\r\n      return ret_arr;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Generates a function for reading a 64bit initeger. For now just reads each\r\n   * 32 bit integer and glues together as a string.\r\n   *\r\n   * @return {Function}        The generated parsing function.\r\n   */\r\n  getQWordReader: function() {\r\n    // let base32Max = 4294967296;\r\n    return function(ds /*, struct */) {\r\n      return ds.readUint32() + \"-\" + ds.readUint32();\r\n\r\n      // let p0 = ds.readUint32();\r\n      // let p1 = ds.readUint32();\r\n      // return base32Max * p1 + p0;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Generates a function for reading a string of 8 bit chars.\r\n   *\r\n   * @return {Function}        The generated parsing function.\r\n   */\r\n  getStringReader: function() {\r\n    return function(ds /*, struct*/) {\r\n      let ptr = ds.position + ds.readUint32();\r\n      let pos = ds.position;\r\n\r\n      /// Go to pointer\r\n      ds.seek(ptr);\r\n\r\n      let ret = ds.readCString();\r\n\r\n      /// Go back to where we were\r\n      ds.seek(pos);\r\n\r\n      return ret;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Generates a function for reading a string of 16 bit chars.\r\n   *\r\n   * @return {Function}        The generated parsing function.\r\n   */\r\n  getString16Reader: function(stringOffset) {\r\n    return function(ds /*, struct*/) {\r\n      let ptr = ds.position + ds.readUint32() + (stringOffset || 0);\r\n      let pos = ds.position;\r\n\r\n      /// Go to pointer\r\n      ds.seek(ptr);\r\n\r\n      let ret = \"\";\r\n      let num;\r\n      while (ds.position + 2 < ds.byteLength && (num = ds.readUint16()) !== 0) {\r\n        ret += String.fromCharCode(num);\r\n      }\r\n      // ds.readCString();\r\n\r\n      /// Go back to where we were\r\n      ds.seek(pos);\r\n\r\n      return ret;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Generates a function for reading a pointer.\r\n   *\r\n   * @param  {Array} structDef DataStream formatted structure definition\r\n   *                           for the item pointed to.\r\n   * @return {Function}        The generated parsing function.\r\n   */\r\n  getPointerReader: function(structDef) {\r\n    return function(ds /*, struct*/) {\r\n      let offset = ds.readUint32();\r\n\r\n      if (offset === 0) {\r\n        return {};\r\n      }\r\n\r\n      let ptr = ds.position - 4 + offset;\r\n      let pos = ds.position;\r\n\r\n      /// Go to pointer\r\n      ds.seek(ptr);\r\n\r\n      let ret = ds.readStruct(structDef);\r\n\r\n      /// Go back to where we were\r\n      ds.seek(pos);\r\n\r\n      return ret;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Generates a function for reading a filename/file Id.\r\n   *\r\n   * @return {Function}        The generated parsing function.\r\n   */\r\n  getFileNameReader: function() {\r\n    return function(ds /*, struct*/) {\r\n      let pos;\r\n      try {\r\n        let ptr = ds.position + ds.readUint32();\r\n        pos = ds.position;\r\n\r\n        /// Go to pointer\r\n        ds.seek(ptr);\r\n\r\n        let fileRef = ds.readStruct([\r\n          \"m_lowPart\",\r\n          \"uint16\", // uint16 m_lowPart;\r\n          \"m_highPart\",\r\n          \"uint16\", // uint16 m_highPart;\r\n          \"m_terminator\",\r\n          \"uint16\" // uint16 m_terminator;\r\n        ]);\r\n\r\n        /// Getting the file name...\r\n        /// Both need to be >= than 256 (terminator is 0)\r\n        let ret =\r\n          0xff00 * (fileRef.m_highPart - 0x100) +\r\n          (fileRef.m_lowPart - 0x100) +\r\n          1;\r\n        // var ret = (fileRef.m_highPart - 0x100) * 0xff00 + (fileRef.m_lowPart - 0xff);\r\n\r\n        if (ret < 0) {\r\n          ret = 0;\r\n          // console.log(\"FR negative\", fileRef.m_highPart, fileRef.m_lowPart, fileRef.m_terminator);\r\n          // debugger;\r\n        }\r\n\r\n        /// Go back to where we were\r\n        ds.seek(pos);\r\n\r\n        return ret;\r\n      } catch (e) {\r\n        /// Go back to where we were\r\n        ds.seek(pos);\r\n\r\n        return -1;\r\n      }\r\n    };\r\n  }\r\n};\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst GW2File = require(\"../format/file/GW2File\");\r\nconst MaterialUtils = require(\"./MaterialUtils\");\r\nconst MathUtils = require(\"./MathUtils\");\r\n\r\n// TODO: Remove this local cache!!\r\nlet matFiles = {};\r\n\r\n/**\r\n * Object describing the meaning of the bits in fvf integers.\r\n * @property fvfFormat\r\n * @private\r\n * @type {Object}\r\n */\r\nlet fvfFormat = {\r\n  Position: 0x00000001 /** < 12 bytes. Position as three 32-bit floats in the order x, y, z. */,\r\n  Weights: 0x00000002 /** < 4 bytes. Contains bone weights. */,\r\n  Group: 0x00000004 /** < 4 bytes. Related to bone weights. */,\r\n  Normal: 0x00000008 /** < 12 bytes. Normal as three 32-bit floats in the order x, y, z. */,\r\n  Color: 0x00000010 /** < 4 bytes. Vertex color. */,\r\n  Tangent: 0x00000020 /** < 12 bytes. Tangent as three 32-bit floats in the order x, y, z. */,\r\n  Bitangent: 0x00000040 /** < 12 bytes. Bitangent as three 32-bit floats in the order x, y, z. */,\r\n  TangentFrame: 0x00000080 /** < 12 bytes. */,\r\n  UV32Mask: 0x0000ff00 /** < 8 bytes for each set bit. Contains UV-coords as two 32-bit floats in the order u, v. */,\r\n  UV16Mask: 0x00ff0000 /** < 4 bytes for each set bit. Contains UV-coords as two 16-bit floats in the order u, v. */,\r\n  Unknown1: 0x01000000 /** < 48 bytes. Unknown data. */,\r\n  Unknown2: 0x02000000 /** < 4 bytes. Unknown data. */,\r\n  Unknown3: 0x04000000 /** < 4 bytes. Unknown data. */,\r\n  Unknown4: 0x08000000 /** < 16 bytes. Unknown data. */,\r\n  PositionCompressed: 0x10000000 /** < 6 bytes. Position as three 16-bit floats in the order x, y, z. */,\r\n  Unknown5: 0x20000000 /** < 12 bytes. Unknown data. **/\r\n};\r\n\r\n/**\r\n * Collection of methods used for generating THREE meshes from Guild Wars 2 data formats.\r\n * @namespace RenderUtils\r\n */\r\n\r\n/**\r\n * Creates a mesh representing a single plane.\r\n *\r\n * @memberof RenderUtils\r\n * @param  {Object} rect     An object with x1,x2,y1 and y2 properties.\r\n * @param  {Number} yPos     Vertical position of the rectangle.\r\n * @param  {THREE.Material} material \tMesh material to apply.\r\n * @param  {Number} dy       Mesh height.\r\n * @return {THREE.Mesh}      The generated mesh.\r\n */\r\nfunction renderRect(rect, yPos, material, dy) {\r\n  let dx = rect.x1 - rect.x2;\r\n  let dz = rect.y1 - rect.y2;\r\n  if (!dy) dy = 1;\r\n\r\n  let cx = (rect.x1 + rect.x2) / 2;\r\n  let cz = (rect.y1 + rect.y2) / 2;\r\n  let cy = yPos;\r\n\r\n  let geometry = new THREE.BoxGeometry(dx, dy, dz);\r\n\r\n  material =\r\n    material ||\r\n    new THREE.MeshBasicMaterial({\r\n      color: 0xff0000,\r\n      wireframe: true\r\n    });\r\n  let plane = new THREE.Mesh(geometry, material);\r\n  plane.overdraw = true;\r\n\r\n  plane.position.x = cx;\r\n  plane.position.y = cy;\r\n  plane.position.z = cz;\r\n\r\n  return plane;\r\n}\r\n\r\n/**\r\n * Load image data into a THREE.Texture from a file within the GW2 .dat file using a LocalReader.\r\n *\r\n * @deprecated Please use the original function from MaterialUtils\r\n * @memberof RenderUtils\r\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\r\n * @param {Number} fileId The fileId or baseId of the file to load image data from.\r\n * @param {Number} mapping What THREE mapping the returned texture will use, not implemented.\r\n * @param  {Array} defaultColor RGBA array of 4 integers. The default solid color of the mesh, should texture loading fail.\r\n * @param {Function} onerror Error callback, not implemented.\r\n *\r\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\r\n */\r\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror) {\r\n  T3D.Logger.log(\r\n    T3D.Logger.TYPE_WARNING,\r\n    \"RenderUtils.loadLocalTexture is deprecated ! Please use the one from MaterialUtils.\"\r\n  );\r\n  return MaterialUtils.loadLocalTexture(\r\n    localReader,\r\n    fileId,\r\n    mapping,\r\n    defaultColor,\r\n    onerror\r\n  );\r\n}\r\n\r\n/**\r\n * Returns a THREE representation of the data contained by a GW2 model file.\r\n * The data is read using a LocalReader reference into the GW2 .dat.\r\n *\r\n * @memberof RenderUtils\r\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\r\n * @param {Object} chunk Model GEOM chunk.\r\n * @param {Object} modelDataChunk Model MODL chunk.\r\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\r\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\r\n *\r\n * @return {Array} Each geometry in the model file represented by a textured THREE.Mesh object\r\n */\r\nfunction renderGeomChunk(\r\n  localReader,\r\n  chunk,\r\n  modelDataChunk,\r\n  sharedTextures,\r\n  showUnmaterialed\r\n) {\r\n  let rawMeshes = chunk.data.meshes;\r\n  let meshes = [];\r\n  let mats = modelDataChunk.data.permutations[0].materials;\r\n\r\n  rawMeshes.forEach(function(rawMesh) {\r\n    let rawGeom = rawMesh.geometry;\r\n    let fvf = rawGeom.verts.mesh.fvf; // rawGeom.fvf;\r\n\r\n    let numVerts = rawGeom.verts.vertexCount; // rawGeom.vertexCount;\r\n\r\n    let rawVerts = rawGeom.verts.mesh.vertices; // rawGeom.vertices\r\n\r\n    let indices = rawGeom.indices.indices;\r\n\r\n    let geom = new THREE.BufferGeometry();\r\n\r\n    let vertDS = new DataStream(rawVerts.buffer);\r\n\r\n    // Dirty step length for now:\r\n    let stride = rawVerts.length / numVerts;\r\n\r\n    // Each vertex\r\n    // DO UV as well\r\n    let vertices = new Float32Array(numVerts * 3);\r\n    // let tangents = null;\r\n    let normals = null;\r\n    let uvs = [];\r\n\r\n    /// Calculate the distance to the first pair of UV data from the\r\n    /// start of the vertex entry\r\n    ///\r\n    let distToNormals =\r\n      !!(fvf & fvfFormat.Position) * 12 +\r\n      !!(fvf & fvfFormat.Weights) * 4 +\r\n      !!(fvf & fvfFormat.Group) * 4;\r\n\r\n    let distToTangent =\r\n      distToNormals +\r\n      !!(fvf & fvfFormat.Normal) * 12 +\r\n      !!(fvf & fvfFormat.Color) * 4;\r\n\r\n    let distToBittangent = distToTangent + !!(fvf & fvfFormat.Tangent) * 12;\r\n\r\n    let distToTangentFrame =\r\n      distToBittangent + !!(fvf & fvfFormat.Bitangent) * 12;\r\n\r\n    let distToUV = distToTangentFrame + !!(fvf & fvfFormat.TangentFrame) * 12;\r\n\r\n    /// Check if the UV is 32 bit float or 16 bit float.\r\n    let uv32Flag = (fvf & fvfFormat.UV32Mask) >> 8;\r\n    let uv16Flag = (fvf & fvfFormat.UV16Mask) >> 16;\r\n    let isUV32 = !!uv32Flag;\r\n    let hasUV = !!uv16Flag || !!uv32Flag;\r\n\r\n    /// Popcount (count the number of binary 1's) in the UV flag\r\n    /// to get the number of UV pairs used in this vertex format.\r\n    let masked = isUV32 ? uv32Flag : uv16Flag;\r\n    let numUV = MathUtils.popcount(masked);\r\n\r\n    numUV = Math.min(numUV, 1.0);\r\n\r\n    /// Create typed UV arrays\r\n    if (hasUV) {\r\n      for (let i = 0; i < numUV; i++) {\r\n        uvs[i] = new Float32Array(numVerts * 2);\r\n      }\r\n    }\r\n\r\n    if (fvf & fvfFormat.Normal) {\r\n      // console.log(\"HAS Normal\");\r\n    }\r\n\r\n    if (fvf & fvfFormat.Tangent) {\r\n      // console.log(\"HAS Tangent\");\r\n    }\r\n\r\n    if (fvf & fvfFormat.Bitangent) {\r\n      // console.log(\"HAS Bitangent\");\r\n    }\r\n    if (fvf & fvfFormat.TangentFrame) {\r\n      // console.log(\"HAS TangentFrame\");\r\n    }\r\n\r\n    /// Read data from each vertex data entry\r\n    for (let i = 0; i < numVerts; i++) {\r\n      /// Go to vertex memory position\r\n      vertDS.seek(i * stride);\r\n\r\n      /// Read position data\r\n      /// (we just hope all meshes has 32 bit position...)\r\n      let x = vertDS.readFloat32();\r\n      let z = vertDS.readFloat32();\r\n      let y = vertDS.readFloat32();\r\n\r\n      /// Write position data, transformed to Tyria3D coordinate system.\r\n      vertices[i * 3 + 0] = x; // - c.x;\r\n      vertices[i * 3 + 1] = -y; // + c.y;\r\n      vertices[i * 3 + 2] = -z; // + c.z;\r\n\r\n      /// Read data at UV position\r\n      if (hasUV) {\r\n        for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\r\n          vertDS.seek(i * stride + distToUV + uvIdx * (isUV32 ? 8 : 4));\r\n\r\n          /// Add one UV pair:\r\n\r\n          let u, v;\r\n          if (isUV32) {\r\n            u = vertDS.readUint32();\r\n            v = vertDS.readUint32();\r\n          } else {\r\n            u = MathUtils.f16(vertDS.readUint16());\r\n            v = MathUtils.f16(vertDS.readUint16());\r\n          }\r\n\r\n          /// Push to correct UV array\r\n          uvs[uvIdx][i * 2 + 0] = u;\r\n          uvs[uvIdx][i * 2 + 1] = v;\r\n        }\r\n      } /// End if has UV\r\n    } /// End each vertex\r\n\r\n    /// Each face descripbed in indices\r\n    let faces = new Uint16Array(indices.length);\r\n    for (let i = 0; i < indices.length; i += 3) {\r\n      // This is ONE face\r\n      faces[i + 0] = indices[i + 2];\r\n      faces[i + 1] = indices[i + 1];\r\n      faces[i + 2] = indices[i + 0];\r\n    } // End each index aka \"face\"\r\n\r\n    /// Add position, index and uv props to buffered geometry\r\n    geom.addAttribute(\"position\", new THREE.BufferAttribute(vertices, 3));\r\n    // geom.addAttribute( 'index', new THREE.BufferAttribute( faces, 1) );\r\n    geom.setIndex(new THREE.BufferAttribute(faces, 1));\r\n\r\n    if (normals) {\r\n      console.log(\"adding normals\");\r\n      geom.addAttribute(\"normal\", new THREE.BufferAttribute(normals, 3));\r\n      geom.normalizeNormals();\r\n      geom.normalsNeedUpdate = true;\r\n    } else {\r\n      /// Calculate normals\r\n      geom.computeVertexNormals();\r\n    }\r\n\r\n    if (hasUV) {\r\n      for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\r\n        /// Names are \"uv\", \"uv2\", \"uv3\", ... , \"uvN\"\r\n        let uvName = \"uv\" + (uvIdx > 0 ? uvIdx + 1 : \"\");\r\n\r\n        /// Set \"custom\" attribute uvN\r\n        geom.addAttribute(uvName, new THREE.BufferAttribute(uvs[uvIdx], 2));\r\n\r\n        /// Flag for update\r\n        geom.attributes[uvName].needsUpdate = true;\r\n      }\r\n\r\n      /// Not needed anymore?\r\n      geom.uvsNeedUpdate = true;\r\n    }\r\n\r\n    /// Tell geometry to update its UVs and buffers\r\n    geom.buffersNeedUpdate = true;\r\n\r\n    /// DONE READING VERTEX DATA\r\n\r\n    /// Get material used for this mesh\r\n    let matIdx = rawMesh.materialIndex;\r\n    let mat = mats[matIdx];\r\n    let materialFile = null;\r\n\r\n    if (mat && matFiles[mat.filename]) {\r\n      materialFile = matFiles[mat.filename];\r\n    }\r\n\r\n    let finalMaterial = MaterialUtils.getMaterial(\r\n      mat,\r\n      materialFile,\r\n      localReader,\r\n      sharedTextures\r\n    );\r\n\r\n    /// IF we could not find a material abort OR use a wireframe placeholder.\r\n    if (!finalMaterial) {\r\n      if (showUnmaterialed) {\r\n        finalMaterial = new THREE.MeshLambertMaterial({\r\n          color: 0x5bb1e8,\r\n          wireframe: false,\r\n          side: THREE.DoubleSide\r\n        });\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n\r\n    /// Create the final mesh from the BufferedGeometry and MeshBasicMaterial\r\n    let finalMesh = new THREE.Mesh(geom, finalMaterial);\r\n\r\n    /// Set material info on the returned mesh\r\n    if (mat) {\r\n      finalMesh.materialFlags = mat.materialFlags;\r\n      finalMesh.materialFilename = mat.filename;\r\n    }\r\n\r\n    finalMesh.materialName = rawMesh.materialName;\r\n\r\n    /// Use materialFilename, materialName, and material.textureFilename in order to build export\r\n\r\n    /// Set lod info on the returned mesh\r\n    finalMesh.numLods = rawMesh.geometry.lods.length;\r\n    finalMesh.lodOverride = modelDataChunk.data.lodOverride;\r\n\r\n    /// Set flag and UV info on the returned mehs\r\n    finalMesh.flags = rawMesh.flags;\r\n    finalMesh.numUV = numUV;\r\n\r\n    /// Add mesh to returned Array\r\n    meshes.push(finalMesh);\r\n  }); /// End rawMeshes forEach\r\n\r\n  return meshes;\r\n}\r\n\r\n/**\r\n * Loads mesh array from Model file and sends as argument to callback.\r\n *\r\n * @memberof RenderUtils\r\n * @async\r\n * @param  {Number} filename Name of the model file to load data from.\r\n * @param  {Array} solidColor RGBA array of 4 integers\r\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\r\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\r\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\r\n\r\n * @param  {Function} callback Fired once all meshes have been loaded.\r\n * two arguments are passed to the callback function.\r\n *\r\n * The first argument is an Array with each textured THREE.Mesh objects.\r\n *\r\n * The second argument is the bounding spehere of this model file.\r\n *\r\n */\r\n\r\nfunction loadMeshFromModelFile(\r\n  filename,\r\n  solidColor,\r\n  localReader,\r\n  sharedTextures,\r\n  showUnmaterialed,\r\n  callback\r\n) {\r\n  // Short handles prop attributes\r\n  let finalMeshes = [];\r\n\r\n  /// Load file\r\n  localReader.loadFile(filename, function(inflatedData) {\r\n    try {\r\n      if (!inflatedData) {\r\n        throw \"Could not find MFT entry for \" + filename;\r\n      }\r\n\r\n      let ds = new DataStream(inflatedData);\r\n\r\n      let modelFile = new GW2File(ds, 0);\r\n\r\n      // MODL for materials -> textures\r\n      let modelDataChunk = modelFile.getChunk(\"modl\");\r\n\r\n      // GEOM for geometry\r\n      let geometryDataChunk = modelFile.getChunk(\"geom\");\r\n\r\n      /// Hacky fix for not being able to adjust for position\r\n      let boundingSphere = modelDataChunk.data.boundingSphere;\r\n      let bsc = boundingSphere.center;\r\n      boundingSphere.radius += Math.sqrt(\r\n        bsc[0] * bsc[0] + Math.sqrt(bsc[1] * bsc[1] + bsc[2] * bsc[2])\r\n      );\r\n\r\n      /// Load all material files\r\n      let allMats = modelDataChunk.data.permutations[0].materials;\r\n\r\n      //eslint-disable-next-line no-inner-declarations\r\n      function loadMaterialIndex(mIdx, matCallback) {\r\n        if (mIdx >= allMats.length) {\r\n          matCallback();\r\n          return;\r\n        }\r\n\r\n        let mat = allMats[mIdx];\r\n\r\n        /// Skip if file is loaded\r\n        if (matFiles[mat.filename]) {\r\n          loadMaterialIndex(mIdx + 1, matCallback);\r\n          return;\r\n        }\r\n\r\n        localReader.loadFile(mat.filename, function(inflatedData) {\r\n          if (inflatedData) {\r\n            let ds = new DataStream(inflatedData);\r\n            let materialFile = new GW2File(ds, 0);\r\n            matFiles[mat.filename] = materialFile;\r\n          }\r\n\r\n          loadMaterialIndex(mIdx + 1, matCallback);\r\n        });\r\n      }\r\n\r\n      loadMaterialIndex(0, function() {\r\n        /// Create meshes\r\n        let meshes = renderGeomChunk(\r\n          localReader,\r\n          geometryDataChunk,\r\n          modelDataChunk,\r\n          sharedTextures,\r\n          showUnmaterialed\r\n        );\r\n\r\n        // Build mesh group\r\n        meshes.forEach(function(mesh) {\r\n          /// Material flags\r\n          let knownflags = [\r\n            /*\r\n\t\t\t\t\t\t\t1-5\r\n\t\t\t\t\t\t\tHas Tex?\tIDK\t\t\tLight?\t\tAlpha?\r\n\r\n\t\t\t\t\t\t\t5-8\r\n\t\t\t\t\t\t\t0\t\t\t0\t \t\tIDK\t\t \tWater?\r\n\r\n\t\t\t\t\t\t\t9-12\r\n\t\t\t\t\t\t\tHas Tex?\t0\t\t\tAlpha?\t\tAlpha?\r\n\r\n\t\t\t\t\t\t\t13\r\n\t\t\t\t\t\t\tIDK KEV\r\n\t\t\t    \t\t*/\r\n\r\n            0, // 0 0000 0000 0000\t\tGround / Wall splashes\r\n            8, // 0 0000 0000 1000\t\tBroken Khylo roof DDS\r\n            9, // 0 0000 0000 1001\t\tTree leaves\r\n\r\n            520, // 0 0010 0000 1000\t\tSome LOD modules, fires, smoke, inside of tents (some DSS textures)\r\n\r\n            2056, // 0 1000 0000 1000\t\tSolid objects, also broken animations\r\n\r\n            /// Solids here are unhappy, or are they? could be animations etc\r\n            2057, // 0 1000 0000 1001\t\tWindmill sails, bushes, trees, but also a statue and a few pieces of wall\r\n\r\n            2060, // 0 1000 0000 1100\t\tA few solid objects, like wooden barricades, one(!) painting\r\n            2061, // 0 1000 0000 1101\t\tA few bushes, two paintings\r\n\r\n            2312, // 0 1001 0000 1000\t\tOpaque Clock tower main walls AND IVY\r\n            2316, // 0 1001 0000 1100\t\tBushes, inner flower walkway a ramp and a box\r\n\r\n            // Number 10\r\n            2568, // 0 1010 0000 1000\t\tLots of solids; walls, tents also some tent details WITH alpa\r\n\r\n            // Number 11\r\n            2569, // 0 1010 0000 1001\t\tSolids like walls and roofs and appernt non solids like ropes\r\n\r\n            2572, // 0 1010 0000 1100\t\tSolid wooden beems, lamp posts\r\n            2573, // 0 1010 0000 1101\t\tLamp holders, bushes, fences, apparent non solids\r\n            2584, // 0 1010 0001 1000\t\tFountain Well water\r\n\r\n            2824, // 0 1011 0000 1000\t\tWindows, sign arrows, cloth roofs (non solids) BUT straw roofs\r\n            2828, // 0 1011 0000 1100\t\tA few fence post (non solids)\r\n            2840, // 0 1011 0001 1000\t\tFountain running water + pipe water\r\n\r\n            4617, // 1 0010 0000 1001\t\tFound nothing\r\n            6664 // 1 1010 0000 1000\t\tTwo groups of solid boxes\r\n          ];\r\n\r\n          // let alphaMask0 = 0x0001 // + 0x0100 + 0x0200;\r\n          // let alphaMask1 = 0x0010\r\n          // let alphaMask2 = 0x0100 + 0x0200\r\n          // let alphaMask2b = 0x0200\r\n\r\n          let texMask = 0x8 + 0x0800;\r\n\r\n          if (knownflags.indexOf(mesh.materialFlags) !== 11) {\r\n            // return;\r\n          }\r\n\r\n          // No smoke etc\r\n          if (mesh.materialFlags === 520) {\r\n            // return;\r\n          }\r\n\r\n          // Must have texture\r\n          if (!showUnmaterialed && !(mesh.materialFlags & texMask)) {\r\n            return;\r\n          }\r\n\r\n          // NO lods\r\n          if (mesh.flags === 4 || mesh.flags === 1 || mesh.flags === 0) {\r\n            // return;\r\n          }\r\n\r\n          // Add to final colection\r\n          finalMeshes.push(mesh);\r\n        }); /// END FOR EACH meshes\r\n\r\n        callback(finalMeshes, boundingSphere);\r\n      }); /// END LOAD MATERIALS CALLBACK\r\n    } catch (e) {\r\n      console.warn(\"Failed rendering model \" + filename, e);\r\n      let mesh = new THREE.Mesh(\r\n        new THREE.BoxGeometry(200, 2000, 200),\r\n        new THREE.MeshNormalMaterial()\r\n      );\r\n      mesh.flags = 4;\r\n      mesh.materialFlags = 2056;\r\n      mesh.lodOverride = [1000000, 1000000];\r\n      finalMeshes.push(mesh);\r\n\r\n      /// Send the final meshes to callback function\r\n      callback(finalMeshes);\r\n    }\r\n  }); /// END FILE LOADED CALLBACK FUNCTION\r\n}\r\n\r\n/**\r\n * Gets a mesh array from Model file and sends as argument to callback. Uses a cache of meshes in order\r\n * to never read the same model file twice.\r\n *\r\n * @memberof RenderUtils\r\n * @async\r\n * @param  {Number} filename The fileId or baseId of the Model file to load\r\n * @param  {Array} color RGBA array of 4 integers\r\n * @param  {LocalReader} localReader The LocalReader object used to read data from the GW2 .dat file.\r\n * @param {Object} sharedMeshes  Value Object for keeping the texture cache.\r\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\r\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\r\n * @param  {Function} callback Fired once all meshes have been loaded.\r\n * three arguments are passed to the callback function.\r\n *\r\n * The first argument is an Array with each textured THREE.Mesh objects.\r\n *\r\n * The second argument is a boolean, true indicates that these meshes were not\r\n * loaded from the dat file, but retrieved from the run time cache.\r\n *\r\n * The third argument is the bounding spehere of this model file.\r\n */\r\nfunction getMeshesForFilename(\r\n  filename,\r\n  color,\r\n  localReader,\r\n  sharedMeshes,\r\n  sharedTextures,\r\n  showUnmaterialed,\r\n  callback\r\n) {\r\n  /// If this file has already been loaded, just return a reference to the meshes.\r\n  /// isCached will be set to true to inform the caller the meshes will probably\r\n  /// have to be cloned in some way.\r\n  if (sharedMeshes[filename]) {\r\n    callback(\r\n      sharedMeshes[filename].meshes,\r\n      true,\r\n      sharedMeshes[filename].boundingSphere\r\n    );\r\n  }\r\n\r\n  /// If this file has never been loaded, load it using loadMeshFromModelFile\r\n  /// the resulting mesh array will be cached within this model's scope.\r\n  else {\r\n    loadMeshFromModelFile(\r\n      filename,\r\n      color,\r\n      localReader,\r\n      sharedTextures,\r\n      showUnmaterialed,\r\n      function(meshes, boundingSphere) {\r\n        /// Cache result if any.\r\n        if (meshes) {\r\n          sharedMeshes[filename] = {\r\n            meshes: meshes,\r\n            boundingSphere: boundingSphere\r\n          };\r\n        }\r\n\r\n        /// Allways fire callback.\r\n        callback(meshes, false, boundingSphere);\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * WIP, Tries to find all fileIds refered by a model file.\r\n *\r\n * @memberof RenderUtils\r\n * @async\r\n * @param  {Number}   filename    Model file Id\r\n * @param  {LocalReader}   localReader LocalReader instance to read from\r\n * @param  {Function} callback   First argument is list of used file IDs\r\n */\r\nfunction getFilesUsedByModel(filename, localReader, callback) {\r\n  let fileIds = [filename];\r\n\r\n  /// Load model file\r\n  localReader.loadFile(filename, function(inflatedData) {\r\n    try {\r\n      if (!inflatedData) {\r\n        throw \"Could not find MFT entry for \" + filename;\r\n      }\r\n\r\n      let ds = new DataStream(inflatedData);\r\n      let modelFile = new GW2File(ds, 0);\r\n\r\n      // MODL for materials -> textures\r\n      let modelDataChunk = modelFile.getChunk(\"modl\");\r\n\r\n      /// Get materials used by model\r\n      let mats = modelDataChunk.data.permutations[0].materials;\r\n\r\n      /// Add each material file AND referenced TEXTURES\r\n      mats.forEach(function(mat) {\r\n        /// Add material file id\r\n        let matFileName = mat.filename;\r\n        fileIds.push(matFileName);\r\n\r\n        /// Add each texture file id\r\n        mat.textures.forEach(function(tex) {\r\n          fileIds.push(tex.filename);\r\n        });\r\n      });\r\n    } catch (e) {\r\n      console.warn(\"Could not export any data\", e);\r\n    }\r\n\r\n    callback(fileIds);\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  renderRect: renderRect,\r\n  loadLocalTexture: loadLocalTexture,\r\n  renderGeomChunk: renderGeomChunk,\r\n  loadMeshFromModelFile: loadMeshFromModelFile,\r\n  getMeshesForFilename: getMeshesForFilename,\r\n  getFilesUsedByModel: getFilesUsedByModel\r\n};\r\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nmodule.exports = {\r\n  /// TODO: port fog from in-engine\r\n\r\n  getFragmentShader: function() {\r\n    return [\r\n      \"uniform vec2 uvScale;\",\r\n      \"uniform vec2 offset;\",\r\n      \"uniform sampler2D texturePicker;\",\r\n      \"uniform sampler2D texturePicker2;\",\r\n      \"uniform sampler2D texture1;\",\r\n      \"uniform sampler2D texture2;\",\r\n      \"uniform sampler2D texture3;\",\r\n      \"uniform sampler2D texture4;\",\r\n\r\n      THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"],\r\n\r\n      \"varying vec2 vUv;\",\r\n      \"varying vec3 vecNormal;\",\r\n\r\n      \"vec3 blend(\",\r\n      \"vec4 texture1, float a1, vec4 texture2, float a2,\",\r\n      \"vec4 texture3, float a3, vec4 texture4, float a4)\",\r\n      \"{\",\r\n      \"float depth = 2.0;\",\r\n      \"float alphaMult = 1.0;\",\r\n      \"float alphaAdd  = 0.0;\",\r\n      \"a1 *= 4.0;\",\r\n      \"a2 *= 4.0;\",\r\n      \"a3 *= 4.0;\",\r\n      \"a4 *= 4.0;\",\r\n      \"a1 =  a1+(1.5+texture1.a);\",\r\n      \"a2 =  a2+(1.5+texture2.a);\",\r\n      \"a3 =  a3+(1.5+texture3.a);\",\r\n      \"a4 =  a4+(1.5+texture4.a);\",\r\n      \"float ma = max(a1,a2);\",\r\n      \"ma = max(ma,a3);\",\r\n      \"ma = max(ma,a4);\",\r\n      \"ma -= depth;\",\r\n      \"float b1 = max(a1 - ma, 0.0);\",\r\n      \"float b2 = max(a2 - ma, 0.0);\",\r\n      \"float b3 = max(a3 - ma, 0.0);\",\r\n      \"float b4 = max(a4 - ma, 0.0);\",\r\n      \"return (\",\r\n      \"texture1.rgb * b1 + texture2.rgb * b2 +\",\r\n      \"texture3.rgb * b3 + texture4.rgb * b4 \",\r\n      \") / (b1 + b2 + b3 + b4);\",\r\n      \"}\",\r\n\r\n      \"void main( void ) {\",\r\n      \"vec2 position = vUv*uvScale;\",\r\n      \"float edge = 1.0/1024.0;\",\r\n      \"vec2 compPos = edge + (vUv*0.25 + offset) * (1.0-edge*2.0);\",\r\n      \"vec4 tp1 = texture2D( texturePicker, compPos);\",\r\n      \"vec4 tp2 = texture2D( texturePicker2, compPos);\",\r\n      \"vec4 composite = tp1;\",\r\n      \"vec4 t1 = texture2D( texture1, position );\",\r\n      \"vec4 t2 = texture2D( texture2, position );\",\r\n      \"vec4 t3 = texture2D( texture3, position );\",\r\n      \"vec4 t4 = texture2D( texture4, position );\",\r\n      \"vec3 color = blend(\",\r\n      \"t1, tp1.a,\",\r\n      \"t2, tp1.b,\",\r\n      \"t3, tp1.g,\",\r\n      \"t4, tp1.r\",\r\n      \");\",\r\n      \"color *= 0.5+tp2.r;\",\r\n      \"gl_FragColor = vec4(color,1.0);\",\r\n      THREE.ShaderChunk[\"logdepthbuf_fragment\"],\r\n      \"}\"\r\n    ].join(\"\\n\");\r\n  },\r\n  getVertexShader: function() {\r\n    return [\r\n      \"varying vec2 vUv;\",\r\n      \"varying vec3 vecNormal;\",\r\n      THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"],\r\n      \"void main()\",\r\n      \"{\",\r\n\r\n      \"vUv =  uv;\",\r\n      \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n      \"vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\",\r\n      \"gl_Position = projectionMatrix * mvPosition;\",\r\n      THREE.ShaderChunk[\"logdepthbuf_vertex\"],\r\n      \"}\"\r\n    ].join(\"\\n\");\r\n  }\r\n};\r\n"]}